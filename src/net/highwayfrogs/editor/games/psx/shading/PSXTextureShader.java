package net.highwayfrogs.editor.games.psx.shading;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import net.highwayfrogs.editor.games.psx.CVector;
import net.highwayfrogs.editor.games.sony.shared.SCByteTextureUV;
import net.highwayfrogs.editor.gui.texture.ITextureSource;
import net.highwayfrogs.editor.utils.Utils;

import java.awt.*;
import java.awt.image.BufferedImage;

/**
 * JavaFX does not give us anywhere near enough control over the 3D rendering pipeline to properly recreate the gouraud shading seen on the PlayStation.
 * This shading is very important to making the worlds render accurately too, since gouraud shading was used extensively to color Frogger maps.
 * While new FrogLord will be using a custom-built 3D engine capable of gouraud shading, a temporary solution is desired.
 * This solution is to create a new texture and apply gouraud shading to that texture. This is extremely resource inefficient, but it was pretty much the only solution before new FrogLord is ready.
 * The images generated by this class place the vertices at the following positions, unless UVs are included:
 * 1---2
 * |  /|
 * | / |
 * |/  |
 * 3---4
 * This order matches how the PSX GPU processes a quad, first using vertices 1-2-3, then 2-3-4, according to <a href="https://psx-spx.consoledev.net/graphicsprocessingunitgpu/">this link</a>.
 * Created by Kneesnap on 12/19/2023.
 */
@Getter
public class PSXTextureShader {
    private static final ThreadLocal<PSXTextureShader> TEXTURE_SHADER_THREAD = ThreadLocal.withInitial(PSXTextureShader::new);
    @SuppressWarnings("MismatchedReadAndWriteOfArray") // It is actually read.
    private final TextureCoordinate[] triangleCoordinates = new TextureCoordinate[3];
    @SuppressWarnings("MismatchedReadAndWriteOfArray") // It is actually read.
    private final CVector[] triangleColors = new CVector[3];
    private final CVector tempColorVector1 = new CVector();
    private final CVector tempColorVector2 = new CVector();
    private final CVector tempColorVector3 = new CVector();
    private static final int GOURAUD_PADDING_PIXELS = 2;

    private PSXTextureShader() {
        for (int i = 0; i < this.triangleCoordinates.length; i++)
            this.triangleCoordinates[i] = new TextureCoordinate();
        for (int i = 0; i < this.triangleColors.length; i++)
            this.triangleColors[i] = new CVector();
    }

    @Getter
    @Setter
    @NoArgsConstructor
    @AllArgsConstructor
    public static class TextureCoordinate {
        private int x;
        private int y;

        /**
         * Set both the X and Y values.
         * @param x The x value.
         * @param y The y value.
         */
        public void setXY(int x, int y) {
            this.x = x;
            this.y = y;
        }

        /**
         * Load the texture coordinates from a texture UV.
         * @param textureSource  The texture source
         * @param uv     The uv to load coordinates from.
         */
        public void loadUV(ITextureSource textureSource, SCByteTextureUV uv) {
            this.x = textureSource.getLeftPadding() + (int) (uv.getFloatU() * textureSource.getUnpaddedWidth());
            this.y = textureSource.getUpPadding() + (int) (uv.getFloatV() * textureSource.getUnpaddedHeight());
        }
    }

    /**
     * Gets the instance of the PSXTextureShader available to this thread.
     */
    private static PSXTextureShader getInstance() {
        return TEXTURE_SHADER_THREAD.get();
    }

    /**
     * Makes a gouraud shaded, untextured image (POLY_G3 / POLY_G4)
     * @param colors The colors to apply to the image. (8 bits, 0 - 255)
     * @return gouraudShadedImage
     */
    public static BufferedImage makeGouraudShadedImage(CVector[] colors) {
        return makeGouraudShadedImage(PSXShadeTextureDefinition.UNTEXTURED_GOURAUD_SIZE, PSXShadeTextureDefinition.UNTEXTURED_GOURAUD_SIZE, colors);
    }

    /**
     * Makes a gouraud shaded, untextured image (POLY_G3 / POLY_G4)
     * @param width  The width of the image.
     * @param height The height of the image.
     * @param colors The colors to apply to the image. (8 bits, 0 - 255)
     * @return gouraudShadedImage
     */
    public static BufferedImage makeGouraudShadedImage(int width, int height, CVector[] colors) {
        BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);

        int startX = PSXShadeTextureDefinition.UNTEXTURED_PADDING_SIZE;
        int startY = PSXShadeTextureDefinition.UNTEXTURED_PADDING_SIZE;
        int endX = width - PSXShadeTextureDefinition.UNTEXTURED_PADDING_SIZE - 1;
        int endY = height - PSXShadeTextureDefinition.UNTEXTURED_PADDING_SIZE - 1;

        PSXTextureShader instance = getInstance();
        TextureCoordinate[] coordinates = instance.getTriangleCoordinates();
        if (colors.length == 3) {
            coordinates[0].setXY(startX, startY);
            coordinates[1].setXY(startX, endY);
            coordinates[2].setXY(endX, startY);
            shadeTriangle(null, image, colors, coordinates);
        } else if (colors.length == 4) {
            CVector[] triangleColors = instance.getTriangleColors();

            // Left triangle. (0, 0 is the top-left corner)
            triangleColors[0].copyFrom(colors[0]);
            triangleColors[1].copyFrom(colors[1]);
            triangleColors[2].copyFrom(colors[2]);
            coordinates[0].setXY(startX, startY);
            coordinates[1].setXY(endX, startY);
            coordinates[2].setXY(startX, endY);
            shadeTriangle(null, image, triangleColors, coordinates);

            // Right triangle. (width, height is the bottom-right corner)
            triangleColors[0].copyFrom(colors[3]);
            triangleColors[1].copyFrom(colors[2]);
            triangleColors[2].copyFrom(colors[1]);
            coordinates[0].setXY(endX, endY);
            coordinates[1].setXY(startX, endY);
            coordinates[2].setXY(endX, startY);
            shadeTriangle(null, image, triangleColors, coordinates);
        } else {
            throw new RuntimeException("Can't create gouraud shaded image with " + colors.length + " colors.");
        }

        fillHorizontalPadding(image, true, true);
        fillVerticalPadding(image, true, true);
        return image;
    }

    /**
     * Makes a gouraud shaded, textured image (POLY_GT3 / POLY_GT4)
     * @param originalImage The original image to create this one from.
     * @param colors        The colors to apply to the image. (8 bits, 0 - 255)
     * @param textureUvs    The texture uvs to use as the corner of the triangles.
     * @return gouraudShadedImage
     */
    public static BufferedImage makeTexturedGouraudShadedImage(BufferedImage originalImage, ITextureSource textureSource, CVector[] colors, SCByteTextureUV[] textureUvs) {
        BufferedImage image = new BufferedImage(originalImage.getWidth(), originalImage.getHeight(), BufferedImage.TYPE_INT_ARGB);

        PSXTextureShader instance = getInstance();
        TextureCoordinate[] coordinates = instance.getTriangleCoordinates();
        if (colors.length == 3) {
            coordinates[0].loadUV(textureSource, textureUvs[0]);
            coordinates[1].loadUV(textureSource, textureUvs[1]);
            coordinates[2].loadUV(textureSource, textureUvs[2]);
            shadeTriangle(originalImage, image, colors, coordinates);
        } else if (colors.length == 4) {
            CVector[] triangleColors = instance.getTriangleColors();

            // Left triangle.
            triangleColors[0].copyFrom(colors[0]);
            triangleColors[1].copyFrom(colors[1]);
            triangleColors[2].copyFrom(colors[2]);
            coordinates[0].loadUV(textureSource, textureUvs[0]);
            coordinates[1].loadUV(textureSource, textureUvs[1]);
            coordinates[2].loadUV(textureSource, textureUvs[2]);
            shadeTriangle(originalImage, image, triangleColors, coordinates);

            // Right triangle.
            triangleColors[0].copyFrom(colors[3]);
            triangleColors[1].copyFrom(colors[2]);
            triangleColors[2].copyFrom(colors[1]);
            coordinates[0].loadUV(textureSource, textureUvs[3]);
            coordinates[1].loadUV(textureSource, textureUvs[2]);
            coordinates[2].loadUV(textureSource, textureUvs[1]);
            shadeTriangle(originalImage, image, triangleColors, coordinates);
        } else {
            throw new RuntimeException("Can't create gouraud shaded image with " + colors.length + " colors.");
        }

        return image;
    }

    /**
     * Applies gouraud shading to an image.
     * @param sourceImage The texture to apply shading to, if one exists.
     * @param targetImage The image to draw the shaded image onto.
     * @param colors The colors of each triangle vertex.
     * @param vertices The position of each triangle vertex.
     */
    public static void shadeTriangle(BufferedImage sourceImage, BufferedImage targetImage, CVector[] colors, TextureCoordinate[] vertices) {
        if (sourceImage != null && (sourceImage.getWidth() != targetImage.getWidth() || sourceImage.getHeight() != targetImage.getHeight()))
            throw new RuntimeException("The source image had dimensions of " + sourceImage.getWidth() + "x" + sourceImage.getHeight() + ", but the target image was " + targetImage.getWidth() + "x" + targetImage.getHeight() + ".");

        // BufferedImage's origin is the top left corner. (Ie: X = 0, Y = 0 is the top left corner)
        // Step 1) Find the scanline bounds.
        int topIndex = -1;
        int leftIndex = -1;
        int rightIndex = -1;

        // Find top index (The vertex which scanlines start from, connecting to left & right index)
        for (int i = 0; i < vertices.length; i++)
            if (topIndex == -1 || vertices[i].getY() < vertices[topIndex].getY())
                topIndex = i;

        // Find left index (This is the left-most scanline index which is not the top index or the right index.)
        for (int i = 0; i < vertices.length; i++) {
            if (i == topIndex)
                continue; // Skip top index, since it can't be both the top and the left/right point.

            if (leftIndex == -1 || vertices[i].getX() < vertices[leftIndex].getX())
                leftIndex = i;
        }

        // Find right index (This is the right-most scanline index which is not the top index or the left index.)
        for (int i = 0; i < vertices.length; i++) {
            if (i != topIndex && i != leftIndex)
                rightIndex = i;
        }

        // Step 2) Scanline
        TextureCoordinate topPos = vertices[topIndex];
        TextureCoordinate leftPos = vertices[leftIndex];
        TextureCoordinate rightPos = vertices[rightIndex];
        int minTriangleY = topPos.getY();
        int maxTriangleY = Math.max(leftPos.getY(), rightPos.getY());
        int topToLeftHeight = leftPos.getY() - topPos.getY();
        int topToRightHeight = rightPos.getY() - topPos.getY();
        int leftToRightHeight = rightPos.getY() - leftPos.getY();
        int rightToLeftHeight = leftPos.getY() - rightPos.getY();
        float inverseLeftSlope = (topToLeftHeight != 0) ? (((float) (leftPos.getX() - topPos.getX())) / topToLeftHeight) : Float.NaN;
        float inverseRightSlope = (topToRightHeight != 0) ? (((float) (rightPos.getX() - topPos.getX())) / topToRightHeight) : Float.NaN;
        float inverseLeftRightSlope = (leftToRightHeight != 0) ? (((float) (rightPos.getX() - leftPos.getX())) / leftToRightHeight) : Float.NaN;
        PSXTextureShader instance = getInstance();

        // Draw the scan-lines.
        int lastLeftLineX = -1, lastRightLineX = -1;
        for (int y = Math.max(0, minTriangleY); y <= Math.min(maxTriangleY, targetImage.getHeight() - 1); y++) {
            CVector leftLineColor;
            int leftLineX;
            if (y < leftPos.getY()) { // Interpolate between top vertex and left vertex.
                int yOffset = (y - minTriangleY);
                leftLineColor = interpolateCVector(colors[topIndex], colors[leftIndex], (float) yOffset / topToLeftHeight, instance.getTempColorVector1());
                leftLineX = topPos.getX() + (int) (inverseLeftSlope * yOffset);
            } else if (y > leftPos.getY()) { // Interpolate between left vertex and right vertex.
                int yOffset = (y - leftPos.getY());
                leftLineColor = interpolateCVector(colors[leftIndex], colors[rightIndex], (float) yOffset / leftToRightHeight, instance.getTempColorVector1());
                leftLineX = leftPos.getX() + (int) (inverseLeftRightSlope * yOffset);
            } else { // Use data directly from the vertex since it's on this scanline.
                leftLineColor = colors[leftIndex];
                leftLineX = leftPos.getX();
            }

            CVector rightLineColor;
            int rightLineX;
            if (y < rightPos.getY()) { // Interpolate between top vertex and right vertex.
                int yOffset = (y - minTriangleY);
                rightLineColor = interpolateCVector(colors[topIndex], colors[rightIndex], (float) yOffset / topToRightHeight, instance.getTempColorVector2());
                rightLineX = topPos.getX() + (int) (inverseRightSlope * yOffset);
            } else if (y > rightPos.getY()) { // Interpolate between right vertex and left vertex.
                int yOffset = (y - rightPos.getY());
                rightLineColor = interpolateCVector(colors[rightIndex], colors[leftIndex], (float) yOffset / rightToLeftHeight, instance.getTempColorVector2());
                rightLineX = rightPos.getX() + (int) (inverseLeftRightSlope * yOffset);
            } else { // Use data directly from the vertex since it's on this scanline.
                rightLineColor = colors[rightIndex];
                rightLineX = rightPos.getX();
            }

            // Ensures the line is always drawn. (MediEvil has situations where the topIndex is somewhat ambiguous, and this ensures the image still draws properly)
            if (leftLineX > rightLineX) {
                int temp = leftLineX;
                leftLineX = rightLineX;
                rightLineX = temp;
            }

            // Fill a scanline.
            int paddingLeftLineX = leftLineX - GOURAUD_PADDING_PIXELS;
            int paddingRightLineX = rightLineX + GOURAUD_PADDING_PIXELS;
            int endOfLineX = Math.min(targetImage.getWidth() - 1, paddingRightLineX);
            for (int x = Math.max(0, paddingLeftLineX); x <= endOfLineX; x++) {
                // If this is padding data, verify the pixel is empty.
                // This is here to deal with quads. When we draw a quad, we draw two triangles.
                // We need to ensure the padding pixels are skipped if there's already another (potentially non-padding) color there.
                boolean isPadding = (x < leftLineX || x >= rightLineX);
                if (isPadding && targetImage.getRGB(x, y) != 0)
                    continue;

                // Calculate interpolation factor.
                float xLerpFactor = .5F;
                if (leftLineX != rightLineX)
                    xLerpFactor = Math.max(0, Math.min(1, ((float) (x - leftLineX)) / (rightLineX - leftLineX)));

                // Apply shading to pixel in scanline.
                CVector pixelColor = interpolateCVector(leftLineColor, rightLineColor, xLerpFactor, instance.getTempColorVector3());
                int pixelRgb = sourceImage != null ? sourceImage.getRGB(Math.max(leftLineX, Math.min(x, rightLineX - 1)), y) : 0;
                shadePixel(sourceImage, targetImage, x, y, pixelRgb, pixelColor);

                // Vertical padding expansion.
                if (!isPadding) {
                    // If this is the minimum Y pixel to be part of the triangle in this column, expand the color vertically.
                    boolean xWrittenLastScanLine = (x >= lastLeftLineX && x < lastRightLineX);
                    if (!xWrittenLastScanLine) // Write vertical shading extension.
                        for (int paddingY = Math.max(0, y - GOURAUD_PADDING_PIXELS); paddingY < y; paddingY++)
                            if (targetImage.getRGB(x, paddingY) == 0)
                                shadePixel(sourceImage, targetImage, x, paddingY, pixelRgb, pixelColor);

                    // Apply shading to extension to the one below.
                    // TODO: This performs unnecessary pixel writes. The alternative is doing this next loop iteration, which means caching the pixel color from last time.
                    // TODO: I'm confident we can avoid an array, by storing the information necessary to re-interpolate.
                    int paddingMaxTriangleY = Math.min(targetImage.getHeight() - 1, y + GOURAUD_PADDING_PIXELS);
                    for (int paddingY = y + 1; paddingY <= paddingMaxTriangleY; paddingY++)
                        if (targetImage.getRGB(x, paddingY) == 0)
                            shadePixel(sourceImage, targetImage, x, paddingY, pixelRgb, pixelColor);
                }
            }

            lastLeftLineX = leftLineX;
            lastRightLineX = rightLineX;
        }
    }

    private static void fillHorizontalPadding(BufferedImage targetImage, boolean fillLeftPadding, boolean fillRightPadding) {
        // Fill in any padding pixels by extending the pixels with color.
        if (fillRightPadding) {
            for (int y = 0; y < targetImage.getHeight(); y++) {
                for (int x = targetImage.getWidth() - 1; x >= 0; x--) {
                    int pixelColor = targetImage.getRGB(x, y);
                    if (pixelColor == 0)
                        continue; // Skip untouched pixels.

                    // Copy the pixels.
                    while (targetImage.getWidth() > ++x)
                        targetImage.setRGB(x, y, pixelColor);

                    break;
                }
            }
        }

        if (fillLeftPadding) {
            for (int y = 0; y < targetImage.getHeight(); y++) {
                for (int x = 0; x < targetImage.getWidth(); x++) {
                    int pixelColor = targetImage.getRGB(x, y);
                    if (pixelColor == 0)
                        continue; // Skip untouched pixels.

                    // Copy the pixels.
                    while (x-- > 0)
                        targetImage.setRGB(x, y, pixelColor);

                    break;
                }
            }
        }
    }

    private static void fillVerticalPadding(BufferedImage targetImage, boolean fillUpPadding, boolean fillDownPadding) {
        // Fill in any padding pixels by extending the pixels with color.
        if (fillDownPadding) {
            for (int x = 0; x < targetImage.getWidth(); x++) {
                for (int y = targetImage.getHeight() - 1; y >= 0; y--) {
                    int pixelColor = targetImage.getRGB(x, y);
                    if (pixelColor == 0)
                        continue; // Skip untouched pixels.

                    // Copy the pixels.
                    while (targetImage.getHeight() > ++y)
                        targetImage.setRGB(x, y, pixelColor);

                    break;
                }
            }
        }

        if (fillUpPadding) {
            for (int x = 0; x < targetImage.getWidth(); x++) {
                for (int y = 0; y < targetImage.getHeight(); y++) {
                    int pixelColor = targetImage.getRGB(x, y);
                    if (pixelColor == 0)
                        continue; // Skip untouched pixels.

                    // Copy the pixels.
                    while (y-- > 0)
                        targetImage.setRGB(x, y, pixelColor);

                    break;
                }
            }
        }
    }

    private static void shadePixel(BufferedImage sourceImage, BufferedImage targetImage, int x, int y, CVector shadeColor) {
        if (sourceImage != null) {
            if (x >= 0 && x < sourceImage.getWidth() && y >= 0 && y < sourceImage.getHeight()) {
                int textureColor = sourceImage.getRGB(x, y);
                shadePixel(sourceImage, targetImage, x, y, textureColor, shadeColor);
            }
        } else {
            shadePixel(null, targetImage, x, y, 0, shadeColor);
        }
    }

    private static void shadePixel(BufferedImage sourceImage, BufferedImage targetImage, int x, int y, int textureColor, CVector shadeColor) {
        if (x < 0 || x >= targetImage.getWidth() || y < 0 || y >= targetImage.getHeight())
            return;

        if (sourceImage != null) {
            byte alpha = Utils.getAlpha(textureColor);
            // If the value exceeds the max, clamp it to the max. Or at least that's what https://psx-spx.consoledev.net/graphicsprocessingunitgpu/ says.
            short red = (short) Math.min(255, (((double) shadeColor.getRedShort() / 127D) * Utils.getRedInt(textureColor)));
            short green = (short) Math.min(255, (((double) shadeColor.getGreenShort() / 127D) * Utils.getGreenInt(textureColor)));
            short blue = (short) Math.min(255, (((double) shadeColor.getBlueShort() / 127D) * Utils.getBlueInt(textureColor)));
            targetImage.setRGB(x, y, Utils.toARGB(Utils.unsignedShortToByte(red), Utils.unsignedShortToByte(green), Utils.unsignedShortToByte(blue), alpha));
        } else {
            targetImage.setRGB(x, y, shadeColor.toARGB());
        }
    }

    /**
     * Makes a flat shaded, untextured image (POLY_F3 / POLY_F4)
     * @param color The color to apply to the image. (8 bits, 0 - 255)
     * @return flatShadedImage
     */
    public static BufferedImage makeFlatShadedImage(CVector color) {
        return makeFlatShadedImage(PSXShadeTextureDefinition.UNTEXTURED_FLAT_SIZE, PSXShadeTextureDefinition.UNTEXTURED_FLAT_SIZE, color);
    }

    /**
     * Makes a flat shaded, untextured image (POLY_F3 / POLY_F4)
     * @param width  The width of the image.
     * @param height The height of the image.
     * @param color  The color to apply to the image. (8 bits, 0 - 255)
     * @return flatShadedImage
     */
    public static BufferedImage makeFlatShadedImage(int width, int height, CVector color) {
        BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);

        Graphics2D graphics = image.createGraphics();
        graphics.setColor(color.toColor());
        graphics.fillRect(0, 0, image.getWidth(), image.getHeight());
        graphics.dispose();

        return image;
    }

    /**
     * Makes a textured flat shaded image (POLY_FT3 / POLY_FT4).
     * @param originalTexture The original texture to apply shading to.
     * @param color           The shading color to apply. (7 bit color range, 0 - 127, NOT 256)
     * @return flatTextureShadedImage
     */
    public static BufferedImage makeTexturedFlatShadedImage(BufferedImage originalTexture, CVector color) {
        BufferedImage newImage = new BufferedImage(originalTexture.getWidth(), originalTexture.getHeight(), BufferedImage.TYPE_INT_ARGB);
        for (int x = 0; x < newImage.getWidth(); x++) {
            for (int y = 0; y < newImage.getHeight(); y++) {
                int textureColor = originalTexture.getRGB(x, y);
                byte alpha = Utils.getAlpha(textureColor);
                // If the value exceeds the max, clamp it to the max. Or at least that's what https://psx-spx.consoledev.net/graphicsprocessingunitgpu/ says should happen for modulation.
                short red = (short) Math.min(255, (((double) color.getRedShort() / 127D) * Utils.getRedInt(textureColor)));
                short green = (short) Math.min(255, (((double) color.getGreenShort() / 127D) * Utils.getGreenInt(textureColor)));
                short blue = (short) Math.min(255, (((double) color.getBlueShort() / 127D) * Utils.getBlueInt(textureColor)));
                newImage.setRGB(x, y, Utils.toARGB(Utils.unsignedShortToByte(red), Utils.unsignedShortToByte(green), Utils.unsignedShortToByte(blue), alpha));
            }
        }

        return newImage;
    }

    /**
     * Interpolate two color vectors.
     * @param a      The first color vector.
     * @param b      The second color vector.
     * @param t      A value between 0 and 1 representing how much of each vector to include.
     * @param result The resulting vector.
     * @return interpolatedColorVector
     */
    public static CVector interpolateCVector(CVector a, CVector b, float t, CVector result) {
        // Clamp the value.
        if (t < 0)
            t = 0;
        if (t > 1)
            t = 1;

        if (result == null)
            result = new CVector();

        result.setRed(Utils.unsignedShortToByte((short) ((a.getRedShort() * (1 - t)) + (b.getRedShort() * t))));
        result.setGreen(Utils.unsignedShortToByte((short) ((a.getGreenShort() * (1 - t)) + (b.getGreenShort() * t))));
        result.setBlue(Utils.unsignedShortToByte((short) ((a.getBlueShort() * (1 - t)) + (b.getBlueShort() * t))));
        return result;
    }
}