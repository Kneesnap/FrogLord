package net.highwayfrogs.editor.games.tgq;

import lombok.SneakyThrows;
import net.highwayfrogs.editor.file.config.Config;
import net.highwayfrogs.editor.file.reader.DataReader;
import net.highwayfrogs.editor.file.writer.DataWriter;
import net.highwayfrogs.editor.utils.Utils;

import java.io.ByteArrayOutputStream;
import java.util.*;
import java.util.zip.Deflater;
import java.util.zip.Inflater;

/**
 * Contains TGQUtils
 * Created by Kneesnap on 8/17/2019.
 */
public class TGQUtils {
    private static boolean loadedFileListConfiguration;
    private static final Map<Integer, String> FILENAMES_BY_HASH = new HashMap<>();
    private static final Map<Integer, List<String>> COLLIDING_FILE_PATHS = new HashMap<>();

    // This list was generated by finding all the hardcoded strings which get hashed in Frogger TGQ PAL PS2.
    // They have all been verified to hash with ignoreCase true.
    private static final List<String> GENERAL_HASHED_STRINGS = Arrays.asList(
            "FrogInst001", "OctTreeSceneMgr", "DontPrepare", "NrmIdle01", "scriptdata",
            "C001FrogParams", "GooHitParticleParam", "frogoo2.img", "ParticleParam", "UdrWtrBubbleParticleParam",
            "bubble.img", "FireBallParticleParam", "spark.img", "SpeedStoneParticleParam", "GOOBER.VTX",
            "S_FIRE.VTX", "HitFlashParticleParam", "S_ICE.VTX", "HitFlashParticleParam", "SnowParticleParam",
            "S_WIND.VTX", "C001NrmReac01.bae", "C001NrmReac02.bae", "C001NrmReac03.bae", "HitPuff1ParticleParam",
            "HitFlyOutParticleParam", "C001FlyTrnsRun.bae", "C001NrmRun01.bae", "C001NrmWalk01.bae",
            "C001NrmWalk02.bae", "IceHitParticleParam", "FireBallParticleParam", "TorchParticleParam",
            "SavPointParticleParam", "SplashParticleParam", "SplashCParticleParam", "C001Shrink.bae",
            "FrogDieParticleParam", "FrogDieGParticleParam", "FrogDieLParticleParam", "FrogDieSParticleParam",
            "GemPickupParticleParam", "StonePickup01", "CoinSprkCParticleParam", "CoinSprkSParticleParam", "CoinSprkGParticleParam",
            "KeyPikupParticleParam", "UniqueItemParticleParam", "ModeAfterMovie", "MovieContinueGame",
            "FrogSpawnParticleParam", "CoinPickupParticleParam", "_kcEnvironment",
            // Event Triggers:
            "LevelUnloadComplete", "EndScreenFade", "LevelBegin", "BeginScreenFade", "LevelLoadComplete",
            "LevelLoad", "LevelUnload", "LevelCompleted", "PlayerAttack", "PlayerDamage", "PlayerDead",
            "CutMovie", "LevelEnd", "LevelUnloadComplete", "LockPlayerControl", "UnlockPlayerControl",
            "DialogBegin", "DialogAdvance", "DialogEnd", "ShakeCameraRand", "TracePublicEvent",
            "EvStartDemoBGM", "MovieCutFog", "StartMovie", "PlayMidMovie01", "PlayMidMovie02", "PlayMidMovie03",
            "PlayMidMovie04", "PlayMidMovie05", "PlayMidMovie06", "PlayMidMovie07", "PlayMidMovie08", "PlayMidMovie09",
            "PlayMidMovie10",
            // Class Names:
            "CCharacter", "CProp", "CCoin", "CMagicGem", "CHealthBug", "CItem",
            "CObjKey", "CObjMap", "CHoneyPot", "CMagicStone",
            "CUniqueItem", "kcCProxyCapsule", "kcCCameraPid", "kcCCamera3P", "kcCGamePad", "WaypointMgr",
            "kcGlobalDialog", "kcCLight", "kcCAnimSet", "kcCModel", "kcCMsgPool", "kcCProcMgr", "kcCSkeleton",
            "kcCProxyTriMesh", "kcCAnimCtl", "kcCCameraBase", "kcCCameraFree", "kcCCameraPid", "kcCActorBase",
            "kcCScriptMgr", "kcCCameraFollow", "kcCWaypoint", "kcCEmitter", "kcCParticleEmitter");

    @SuppressWarnings("IfStatementMissingBreakInLoop")
    private static void loadFileList() {
        if (loadedFileListConfiguration)
            return;

        loadedFileListConfiguration = true;

        Config config = new Config(Utils.getResourceStream("tgq/file-list.cfg"));
        for (Config fileListCfg : config.getOrderedChildren()) {
            for (String filePath : fileListCfg.getText()) {
                if (filePath.equalsIgnoreCase("UNKNOWN") || filePath.trim().isEmpty())
                    continue;

                int hash = hashFilePath(filePath);

                // Test if this file path matches an existing collision.
                List<String> collidingPaths = COLLIDING_FILE_PATHS.get(hash);
                if (collidingPaths != null) {
                    boolean pathAlreadySeen = false;
                    for (int i = 0; i < collidingPaths.size() && !pathAlreadySeen; i++)
                        if (collidingPaths.get(i).equalsIgnoreCase(filePath))
                            pathAlreadySeen = true;

                    // Found a new instance of the path, skip...!
                    if (!pathAlreadySeen)
                        collidingPaths.add(filePath);

                    continue;
                }

                String oldPath = FILENAMES_BY_HASH.putIfAbsent(hash, filePath);
                if (oldPath != null && !oldPath.equalsIgnoreCase(filePath)) {
                    // A collision has been found.
                    collidingPaths = new ArrayList<>();
                    collidingPaths.add(oldPath);
                    collidingPaths.add(filePath);
                    COLLIDING_FILE_PATHS.put(hash, collidingPaths);
                    if (!FILENAMES_BY_HASH.remove(hash, oldPath))
                        throw new RuntimeException("Failed to remove colliding hash from file name list.");
                }
            }
        }
    }

    /**
     * Apply default name hashes to a name hash map.
     * @param nameMap The map to update.
     */
    public static void addDefaultHashesToMap(Map<Integer, String> nameMap) {
        for (String str : GENERAL_HASHED_STRINGS)
            nameMap.putIfAbsent(hash(str), str);

        for (kcClassID classID : kcClassID.values())
            if (classID.getName() != null && classID.getName().length() > 0)
                nameMap.putIfAbsent(hash(classID.getName()), classID.getName());
    }

    /**
     * Adds hardcoded file paths by their hashes to the map provided.
     * @param nameMap The map to update.
     */
    public static void addHardcodedFileNameHashesToMap(Map<Integer, String> nameMap) {
        loadFileList();
        nameMap.putAll(FILENAMES_BY_HASH);
    }

    /**
     * Compress data with zlib compression.
     * @param data The data to compress.
     * @return compressedData
     */
    @SneakyThrows
    public static byte[] zlibCompress(byte[] data) {
        Deflater deflater = new Deflater();
        deflater.setInput(data);
        ByteArrayOutputStream outputStream = new ByteArrayOutputStream(data.length);
        deflater.finish();
        byte[] buffer = new byte[1024];
        while (!deflater.finished()) {
            int count = deflater.deflate(buffer); // returns the generated code... index
            outputStream.write(buffer, 0, count);
        }
        outputStream.close();
        return outputStream.toByteArray();
    }

    /**
     * Decompress zlib data.
     * @param data The zlib data to decompress.
     * @return decompressedData
     */
    @SneakyThrows
    public static byte[] zlibDecompress(byte[] data, int resultSize) {
        byte[] result = new byte[resultSize];
        Inflater inflater = new Inflater();
        inflater.setInput(data);
        inflater.inflate(result);
        inflater.end();
        return result;
    }

    public static final String[] GAME_PATH_INDEX_PATTERNS = {"\\Game", "\\game", "\\GAME"};
    private static final String[] LEVEL_PATH_INDEX_PATTERNS = {"\\Level", "\\level", "\\LEVEL"};

    /**
     * Creates a file ID from a file path.
     * Example File Path: \\Netapp1\PD\Frogger1\PC\KatWorking\GameSource\Level01RollingRapids\Props\WalTreGL\WALTREGL.VTX
     * Example File ID: S01sPWalTreGL\WALTREGLX
     * The real game does not have any kind of error checking on file paths, for instance reading parts of the name which are not part of the string.
     * We may want to implement exceptions for this at a later date, even though the original game does not.
     * It also could stand to use some cleanup, but I want to keep this functionally identical for now.
     * Notes: The PC version is different from the PS2 version. This function was reversed from PS2, and modified for PC.
     * @param filePath The path to generate a file ID from.
     * @return fileId
     */
    public static String getFileIdFromPath(String filePath) { // Reversed from the 'Hash' function, in the global namespace. (To make it distinct from the other hash method)
        int gameIndex = indexOfMultiple(filePath, GAME_PATH_INDEX_PATTERNS);

        StringBuilder fileId = new StringBuilder();
        if (gameIndex != -1) { // If it was found.
            String cutPath = filePath.substring(gameIndex + 6); // Cut out \\game and everything before it.
            fileId.append(filePath.charAt(gameIndex + 5));
            int levelIndex = indexOfMultiple(cutPath, LEVEL_PATH_INDEX_PATTERNS);

            if (levelIndex != -1) {
                fileId.append(cutPath.charAt(levelIndex + 6));
                fileId.append(cutPath.charAt(levelIndex + 7));

                String cutSepString = cutPath.substring(levelIndex + 8);
                int sepIndex = cutSepString.indexOf('\\');
                if (sepIndex != -1) {
                    fileId.append(cutPath.charAt(levelIndex + 7 + sepIndex)); // Yes, this can result in getting data that is not in cutSepString, which is why it's getting it from cutPath.
                    fileId.append(cutSepString.charAt(sepIndex + 1));

                    String remaining = cutSepString.substring(sepIndex + 2);
                    int nextDirIndex = remaining.indexOf('\\');
                    if (nextDirIndex != -1) {
                        String fileName = remaining.substring(nextDirIndex + 1);
                        int extensionIndex = fileName.indexOf('.');
                        if (extensionIndex != -1) {
                            fileId.append(fileName, 0, extensionIndex);
                            fileId.append(fileName, fileName.length() - 1, fileName.length());
                            return fileId.toString();
                        }
                        return fileId.append(fileName).toString();
                    }
                    return fileId.append(remaining).toString();
                }
                return fileId.append(cutSepString).toString();
            }
            return fileId.append(cutPath).toString();
        }

        return fileId.append(filePath).toString();
    }

    /**
     * Calculates the checksum / hash of a string.
     * @param str The hash to use.
     * @return hash
     */
    public static int hash(String str) {
        return hash(str, true);
    }

    /**
     * Calculates the checksum / hash of a file path after it has been abbreviated.
     * @param filePath The file path to abbreviate and hash..
     * @return hash
     */
    public static int hashFilePath(String filePath) {
        return hash(getFileIdFromPath(filePath), true);
    }

    /**
     * Calculates the checksum / hash of a string.
     * This value is directly what is used in the Table of contents chunk.
     * @param str        The hash to use.
     * @param ignoreCase Whether case should be considered when hashing. There is no known situation where this should be false..
     * @return hash
     */
    public static int hash(String str, boolean ignoreCase) { // Reverse engineered the "Hash" function, in the kcHash (Hash table) namespace.
        if (str == null || str.isEmpty())
            return 0;

        int hash = str.length();
        for (int i = 0; i < str.length(); i++) {
            char tempChar = str.charAt(i);
            if (ignoreCase && (tempChar >= 'A') && (tempChar <= 'Z')) // If the letter is upper-case.
                tempChar = Character.toLowerCase(tempChar);

            hash = ((hash << 4) | ((hash >> 28) & 0x0F)) ^ (int) tempChar; // I'm pretty sure it's closer to the >>> behavior, but this works properly right now.
        }

        return hash;
    }

    /**
     * Find the index a string is found at, doing a case-insensitive search.
     * @param input    The string to search.
     * @param patterns The strings to find.
     * @return indexOfString
     */
    public static int indexOfMultiple(String input, String... patterns) {
        if (input == null || patterns == null || patterns.length == 0)
            return -1;

        for (int i = 0; i < patterns.length; i++) {
            int index = input.indexOf(patterns[i]);
            if (index != -1)
                return index;
        }

        return -1;
    }

    /**
     * Reads a boolean from the reader in the format Frogger TGQ stores them.
     * TODO: When porting to MTF, make this an extension method for reading this kind of bool. readKcBool().
     * @param reader The reader to read from.
     * @return boolValue
     */
    public static boolean readTGQBoolean(DataReader reader) {
        int boolNumber = reader.readInt();
        if (boolNumber != 1 && boolNumber != 0)
            throw new RuntimeException("The int32 value was expected to be a boolean, but was actually " + boolNumber + ".");
        return boolNumber != 0;
    }

    /**
     * Writes a boolean in the format Frogger TGQ stores them.
     * @param writer The writer to write to.
     * @param value  The boolean value to write.
     */
    public static void writeTGQBoolean(DataWriter writer, boolean value) {
        writer.writeInt(value ? 1 : 0);
    }
}
