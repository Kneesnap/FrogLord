package net.highwayfrogs.editor.games.konami.greatquest;

import lombok.SneakyThrows;
import net.highwayfrogs.editor.Constants;
import net.highwayfrogs.editor.file.config.Config;
import net.highwayfrogs.editor.file.reader.DataReader;
import net.highwayfrogs.editor.file.vlo.ImageWorkHorse;
import net.highwayfrogs.editor.file.writer.DataWriter;
import net.highwayfrogs.editor.games.konami.greatquest.GreatQuestHash.kcHashedResource;
import net.highwayfrogs.editor.games.konami.greatquest.entity.kcBaseDesc;
import net.highwayfrogs.editor.games.konami.greatquest.generic.kcCResourceGeneric;
import net.highwayfrogs.editor.games.konami.greatquest.toc.kcCResource;
import net.highwayfrogs.editor.utils.IGameObject;
import net.highwayfrogs.editor.utils.Utils;

import java.awt.image.BufferedImage;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.util.*;
import java.util.function.Function;
import java.util.zip.Deflater;
import java.util.zip.Inflater;

/**
 * Contains static utilities for The Great Quest.
 * Created by Kneesnap on 8/17/2019.
 */
public class GreatQuestUtils {
    private static boolean loadedFileListConfiguration;
    private static final Map<Integer, String> FILENAMES_BY_HASH = new HashMap<>();
    private static final Map<Integer, List<String>> COLLIDING_FILE_PATHS = new HashMap<>();

    // This list was generated by finding all the hardcoded strings which get hashed in Frogger TGQ PAL PS2.
    // They have all been verified to hash with ignoreCase true.
    private static final List<String> GENERAL_HASHED_STRINGS = Arrays.asList(
            "FrogInst001", "OctTreeSceneMgr", "DontPrepare", "NrmIdle01", "scriptdata",
            "C001FrogParams", "GooHitParticleParam", "frogoo2.img", "ParticleParam", "UdrWtrBubbleParticleParam",
            "bubble.img", "FireBallParticleParam", "spark.img", "SpeedStoneParticleParam", "GOOBER.VTX",
            "S_FIRE.VTX", "HitFlashParticleParam", "S_ICE.VTX", "HitFlashParticleParam", "SnowParticleParam",
            "S_WIND.VTX", "C001NrmReac01.bae", "C001NrmReac02.bae", "C001NrmReac03.bae", "HitPuff1ParticleParam",
            "HitFlyOutParticleParam", "C001FlyTrnsRun.bae", "C001NrmRun01.bae", "C001NrmWalk01.bae",
            "C001NrmWalk02.bae", "IceHitParticleParam", "FireBallParticleParam", "TorchParticleParam",
            "SavPointParticleParam", "SplashParticleParam", "SplashCParticleParam", "C001Shrink.bae",
            "FrogDieParticleParam", "FrogDieGParticleParam", "FrogDieLParticleParam", "FrogDieSParticleParam",
            "GemPickupParticleParam", "StonePickup01", "CoinSprkCParticleParam", "CoinSprkSParticleParam", "CoinSprkGParticleParam",
            "KeyPikupParticleParam", "UniqueItemParticleParam", "ModeAfterMovie", "MovieContinueGame",
            "FrogSpawnParticleParam", "CoinPickupParticleParam", "_kcEnvironment",
            // Event Triggers:
            "LevelUnloadComplete", "EndScreenFade", "LevelBegin", "BeginScreenFade", "LevelLoadComplete",
            "LevelLoad", "LevelUnload", "LevelCompleted", "PlayerAttack", "PlayerDamage", "PlayerDead",
            "CutMovie", "LevelEnd", "LevelUnloadComplete", "LockPlayerControl", "UnlockPlayerControl",
            "DialogBegin", "DialogAdvance", "DialogEnd", "ShakeCameraRand", "TracePublicEvent",
            "EvStartDemoBGM", "MovieCutFog", "StartMovie", "PlayMidMovie01", "PlayMidMovie02", "PlayMidMovie03",
            "PlayMidMovie04", "PlayMidMovie05", "PlayMidMovie06", "PlayMidMovie07", "PlayMidMovie08", "PlayMidMovie09",
            "PlayMidMovie10",
            // Class Names:
            "CStats", "CInventory", "CCharacter", "CPropList", "kcCSensor", "CWaterMgr", "CSkyDome", "kcCAnimCtlBase",
            "kcCCameraStack", "kcCDialog", "kcCConsoleMain", "kcCParser", "kcCEnvironment", "kcCWaypointMgr",
            "kcCSceneMgr", "kcCAlarmMgr", "kcCEventMgr", "kcCResourceMgr", "kcCGameSystem", "kcCProxy", "kcCActor",
            "kcCHealth", "kcCEntity", "kcCTriMesh", "kcCEntity3D", "kcCResourceNamedHash", "kcCResourceActionSequence",
            "CCoin", "CGem", "CMagicGem", "CHealthBug", "CItem", "CUniqueItem",
            "CCharacter", "CObjKey", "CObjMap", "CHoneyPot", "CMagicStone", "CProp",
            "CUniqueItem", "kcCProxyCapsule", "kcCCameraPid", "kcCCamera3P", "kcCGamePad", "WaypointMgr",
            "kcGlobalDialog", "kcCLight", "kcCAnimSet", "kcCModel", "kcCMsgPool", "kcCProcMgr", "kcCSkeleton",
            "kcCProxyTriMesh", "kcCAnimCtl", "kcCCameraBase", "kcCCameraFree", "kcCCameraPid", "kcCActorBase",
            "kcCScriptMgr", "kcCCameraFollow", "kcCWaypoint", "kcCEmitter", "kcCParticleEmitter");

    @SuppressWarnings("IfStatementMissingBreakInLoop")
    private static void loadFileList() {
        if (loadedFileListConfiguration)
            return;

        loadedFileListConfiguration = true;

        Config config = new Config(GreatQuestGameType.INSTANCE.getEmbeddedResourceStream("file-list.cfg"));
        for (Config fileListCfg : config.getOrderedChildren()) {
            for (String filePath : fileListCfg.getText()) {
                if (filePath.equalsIgnoreCase("UNKNOWN") || filePath.trim().isEmpty())
                    continue;

                int hash = hashFilePath(filePath);

                // Test if this file path matches an existing collision.
                List<String> collidingPaths = COLLIDING_FILE_PATHS.get(hash);
                if (collidingPaths != null) {
                    boolean pathAlreadySeen = false;
                    for (int i = 0; i < collidingPaths.size() && !pathAlreadySeen; i++)
                        if (collidingPaths.get(i).equalsIgnoreCase(filePath))
                            pathAlreadySeen = true;

                    // Found a new instance of the path, skip...!
                    if (!pathAlreadySeen)
                        collidingPaths.add(filePath);

                    continue;
                }

                String oldPath = FILENAMES_BY_HASH.putIfAbsent(hash, filePath);
                if (oldPath != null && !oldPath.equalsIgnoreCase(filePath)) {
                    // A collision has been found.
                    collidingPaths = new ArrayList<>();
                    collidingPaths.add(oldPath);
                    collidingPaths.add(filePath);
                    COLLIDING_FILE_PATHS.put(hash, collidingPaths);
                    if (!FILENAMES_BY_HASH.remove(hash, oldPath))
                        throw new RuntimeException("Failed to remove colliding hash from file name list.");
                }
            }
        }
    }

    /**
     * Apply default name hashes to a name hash map.
     * @param nameMap The map to update.
     */
    public static void addDefaultHashesToMap(Map<Integer, String> nameMap) {
        for (String str : GENERAL_HASHED_STRINGS)
            nameMap.putIfAbsent(hash(str), str);

        for (kcClassID classID : kcClassID.values())
            if (classID.getName() != null && classID.getName().length() > 0)
                nameMap.putIfAbsent(hash(classID.getName()), classID.getName());
    }

    /**
     * Adds hardcoded file paths by their hashes to the map provided.
     * @param nameMap The map to update.
     */
    public static void addHardcodedFileNameHashesToMap(Map<Integer, String> nameMap) {
        loadFileList();
        nameMap.putAll(FILENAMES_BY_HASH);
    }

    /**
     * Compress data with zlib compression.
     * @param data The data to compress.
     * @return compressedData
     */
    @SneakyThrows
    public static byte[] zlibCompress(byte[] data) {
        Deflater deflater = new Deflater();
        deflater.setInput(data);
        ByteArrayOutputStream outputStream = new ByteArrayOutputStream(data.length);
        deflater.finish();
        byte[] buffer = new byte[1024];
        while (!deflater.finished()) {
            int count = deflater.deflate(buffer); // returns the generated code... index
            outputStream.write(buffer, 0, count);
        }
        outputStream.close();
        deflater.end();
        return outputStream.toByteArray();
    }

    /**
     * Decompress zlib data.
     * @param data The zlib data to decompress.
     * @return decompressedData
     */
    @SneakyThrows
    public static byte[] zlibDecompress(byte[] data, int resultSize) {
        byte[] result = new byte[resultSize];
        Inflater inflater = new Inflater();
        inflater.setInput(data);
        inflater.inflate(result);
        inflater.end();
        return result;
    }

    public static final String[] GAME_PATH_INDEX_PATTERNS = {"\\Game", "\\game", "\\GAME"};
    private static final String[] LEVEL_PATH_INDEX_PATTERNS = {"\\Level", "\\level", "\\LEVEL"};

    /**
     * Creates a file ID from a file path.
     * Example File Path: \\Netapp1\PD\Frogger1\PC\KatWorking\GameSource\Level01RollingRapids\Props\WalTreGL\WALTREGL.VTX
     * Example File ID: S01sPWalTreGL\WALTREGLX
     * The real game does not have any kind of error checking on file paths, for instance reading parts of the name which are not part of the string.
     * We may want to implement exceptions for this at a later date, even though the original game does not.
     * It also could stand to use some cleanup, but I want to keep this functionally identical for now.
     * Notes: The PC version is different from the PS2 version. This function was reversed from PS2, and modified for PC.
     * @param filePath The path to generate a file ID from.
     * @return fileId
     */
    public static String getFileIdFromPath(String filePath) { // Reversed from the 'Hash' function, in the global namespace. (To make it distinct from the other hash method)
        int gameIndex = indexOfMultiple(filePath, GAME_PATH_INDEX_PATTERNS);

        if (gameIndex != -1) { // If it was found.
            StringBuilder fileId = new StringBuilder();
            String cutPath = filePath.substring(gameIndex + 6); // Cut out \\game and everything before it.
            fileId.append(filePath.charAt(gameIndex + 5));
            int levelIndex = indexOfMultiple(cutPath, LEVEL_PATH_INDEX_PATTERNS);

            if (levelIndex != -1) {
                fileId.append(cutPath.charAt(levelIndex + 6));
                fileId.append(cutPath.charAt(levelIndex + 7));

                String cutSepString = cutPath.substring(levelIndex + 8);
                int sepIndex = cutSepString.indexOf('\\');
                if (sepIndex != -1) {
                    fileId.append(cutPath.charAt(levelIndex + 7 + sepIndex)); // Yes, this can result in getting data that is not in cutSepString, which is why it's getting it from cutPath.
                    fileId.append(cutSepString.charAt(sepIndex + 1));

                    String remaining = cutSepString.substring(sepIndex + 2);
                    int nextDirIndex = remaining.indexOf('\\');
                    if (nextDirIndex != -1) {
                        String fileName = remaining.substring(nextDirIndex + 1);
                        int extensionIndex = fileName.indexOf('.');
                        if (extensionIndex != -1) {
                            fileId.append(fileName, 0, extensionIndex);
                            fileId.append(fileName, fileName.length() - 1, fileName.length());
                            return fileId.toString();
                        }
                        return fileId.append(fileName).toString();
                    }
                    return fileId.append(remaining).toString();
                }
                return fileId.append(cutSepString).toString();
            }
            return fileId.append(cutPath).toString();
        } else {
            return filePath;
        }
    }

    /**
     * Calculates the checksum / hash of a string.
     * @param str The hash to use.
     * @return hash
     */
    public static int hash(String str) {
        return hash(str, true);
    }

    /**
     * Calculates the checksum / hash of a file path after it has been abbreviated.
     * @param filePath The file path to abbreviate and hash..
     * @return hash
     */
    public static int hashFilePath(String filePath) {
        return hash(getFileIdFromPath(filePath), true);
    }

    /**
     * Calculates the checksum / hash of a string.
     * This value is directly what is used in the Table of contents chunk.
     * @param str        The hash to use.
     * @param ignoreCase Whether case should be considered when hashing. There is no known situation where this should be false..
     * @return hash
     */
    public static int hash(String str, boolean ignoreCase) { // Reverse engineered the "Hash" function, in the kcHash (Hash table) namespace.
        if (str == null || str.isEmpty())
            return 0;

        int hash = str.length();
        for (int i = 0; i < str.length(); i++) {
            char tempChar = str.charAt(i);
            if (ignoreCase && (tempChar >= 'A') && (tempChar <= 'Z')) // If the letter is upper-case.
                tempChar = Character.toLowerCase(tempChar);

            hash = ((hash << 4) | ((hash >> 28) & 0x0F)) ^ (int) tempChar; // I'm pretty sure it's closer to the >>> behavior, but this works properly right now.
        }

        return hash;
    }

    /**
     * Undo a suffix from the hash.
     * If you have two or more hashes with a shared prefix, and know the suffix of each of the hashes that will make them match.
     * This hash is supposed to represent the hash of the original string, if it had been hashed with the suffix chopped off.
     * However, due to the length of the string being included in the hash, up to two bytes of the hash will not be the expected value.
     * If these bytes were together XOR'd with the full string length, then XOR'd by the chopped string length, that would correct this hash to become the hash of the chopped string.
     * For example reverseHash(DDFCEF0E, 'spike01g') -> 9B018C7E, where the real hash for 'S16nPTnlFence\' is 83018C7E. (9B vs 83).
     * When there are multiple hashes (multiple strings), it is possible to use this to our advantage, since it tells us which byte is modulo 8 of the real string length. (The byte which differs between two hashes of different length strings must be the one which has the length data, and we can calculate modulo 8 of the real string length from that.)
     * So in theory with multiple strings, it should be possible to calculate the full length of each string by looping through each string length with the correct modulo, then calculating the length of each provided string based on the calculated prefix length and the provided suffix length, then using XOR to tell which lengths cause a match between both hashes.
     * Whew that's kinda long-winded and not super clear, but I'm not sure if we'll ever need that functionality.
     *
     * Example:
     * File 1065 in PS2 PAL (\GameSource\Level01RollingRapids\Props\TunlGate\doorhndl copy.img) and File 1066 (\GameSource\Level01RollingRapids\Props\TunlGate\logend copy.img)
     * These files gave me a very hard time, because I saw there was already a folder called "TunlGate". Multiple 3D models use images that look like this, so I was confident that the file names "doorhndl.img" and "logend.img" were correct.
     * All of my effort went into trying to crack the folder name. "TunlGateOld", "TunlGateCopy", "TunlGate Copy", etc.
     * It wasn't until I tried reverse hashing to obtain the common prefix did it become clear that either there was no common prefix (highly unlikely given the sorted nature of the file list), or that I had given the wrong suffixes (file names).
     * From there I was able to instead focus on the file names, and easily found the " copy" was the part I had been missing.
     *
     * @param suffix The suffix known to be used at the end of the original string.
     * @param ignoreCase Whether case should be considered when hashing. There is no known situation where this should be false.
     * @return reversedHash
     */
    public static int reverseHash(int hash, String suffix, boolean ignoreCase) { // Reverse engineered the "Hash" function, in the kcHash (Hash table) namespace.
        if (suffix == null || suffix.isEmpty())
            return hash;

        for (int i = suffix.length() - 1; i >= 0; i--) {
            char tempChar = suffix.charAt(i);
            if (ignoreCase && (tempChar >= 'A') && (tempChar <= 'Z')) // If the letter is upper-case.
                tempChar = Character.toLowerCase(tempChar);

            hash ^= tempChar;
            hash = (hash >>> 4) | (hash << 28);
        }

        return hash;
    }

    /**
     * Find the index a string is found at, doing a case-insensitive search.
     * @param input    The string to search.
     * @param patterns The strings to find.
     * @return indexOfString
     */
    public static int indexOfMultiple(String input, String... patterns) {
        if (input == null || patterns == null || patterns.length == 0)
            return -1;

        for (int i = 0; i < patterns.length; i++) {
            int index = input.indexOf(patterns[i]);
            if (index != -1)
                return index;
        }

        return -1;
    }

    /**
     * Reads a boolean from the reader in the format Frogger TGQ stores them.
     * TODO: When porting to MTF, make this an extension method for reading this kind of bool. readKcBool().
     * @param reader The reader to read from.
     * @return boolValue
     */
    public static boolean readTGQBoolean(DataReader reader) {
        int boolNumber = reader.readInt();
        if (boolNumber != 1 && boolNumber != 0)
            throw new RuntimeException("The int32 value was expected to be a boolean, but was actually " + boolNumber + ".");
        return boolNumber != 0;
    }

    /**
     * Writes a boolean in the format Frogger TGQ stores them.
     * @param writer The writer to write to.
     * @param value  The boolean value to write.
     */
    public static void writeTGQBoolean(DataWriter writer, boolean value) {
        writer.writeInt(value ? 1 : 0);
    }

    /**
     * Gets a Java file representing the file path to export an internal game system file to.
     * @param baseFolder The base folder to extract game files to.
     * @param file       The file to export.
     * @return exportFile
     */
    public static File getExportFile(File baseFolder, GreatQuestArchiveFile file) {
        File exportFolder;
        String fileName = null;
        if (file.hasFilePath()) {
            String tempPath = file.getFilePath();
            while (tempPath.startsWith("\\"))
                tempPath = tempPath.substring(1);

            int lastBackslash = tempPath.lastIndexOf('\\');
            if (lastBackslash != -1) {
                fileName = tempPath.substring(lastBackslash + 1);
                tempPath = tempPath.substring(0, lastBackslash);
            }

            exportFolder = new File(baseFolder, tempPath);
        } else {
            exportFolder = new File(new File(baseFolder, "Unidentified Files/"), file.getDefaultFolderName() + "/");
        }

        if (Utils.isNullOrEmpty(fileName))
            fileName = file.getExportName();

        Utils.makeDirectory(exportFolder);
        return new File(exportFolder, fileName);
    }

    /**
     * Resolves a resource hash to a particular asset.
     * @param resourceClass the desired resource class
     * @param resource the game object resolving the hash.
     * @param hashObj the hash object to save results within
     * @param hash the numerical hash to resolve.
     * @return if the resource was successfully resolved
     * @param <TResource> the type of resource to resolve
     */
    public static <TResource extends kcHashedResource> boolean resolveResourceHash(Class<TResource> resourceClass, kcCResource resource, GreatQuestHash<TResource> hashObj, int hash, boolean warnIfNotFound) {
        return resolveResourceHash(resourceClass, resource.getParentFile(), resource, hashObj, hash, warnIfNotFound);
    }

    /**
     * Resolves a resource hash to a particular asset.
     * @param resourceClass the desired resource class
     * @param gameObj the game object resolving the hash.
     * @param hashObj the hash object to save results within
     * @param hash the numerical hash to resolve.
     * @return if the resource was successfully resolved
     * @param <TResource> the type of resource to resolve
     */
    public static <TResource extends kcHashedResource> boolean resolveResourceHash(Class<TResource> resourceClass, kcBaseDesc gameObj, GreatQuestHash<TResource> hashObj, int hash, boolean warnIfNotFound) {
        return resolveResourceHash(resourceClass, gameObj.getParentFile(), gameObj, hashObj, hash, warnIfNotFound);
    }

    /**
     * Resolves a resource hash to a particular asset.
     * @param resourceClass the desired resource class
     * @param parentFile the file to find assets within
     * @param gameObj the game object resolving the hash.
     * @param hashObj the hash object to save results within
     * @param hash the numerical hash to resolve.
     * @param warnIfNotFound if true and the resource is not found, a warning will be written.
     * @return if the resource was successfully resolved
     * @param <TResource> the type of resource to resolve
     */
    public static <TResource extends kcHashedResource> boolean resolveResourceHash(Class<TResource> resourceClass, GreatQuestChunkedFile parentFile, IGameObject gameObj, GreatQuestHash<TResource> hashObj, int hash, boolean warnIfNotFound) {
        if (resourceClass == null)
            throw new NullPointerException("resourceClass");
        if (gameObj == null)
            throw new NullPointerException("gameObj");
        if (hashObj == null)
            throw new NullPointerException("hashObj");

        // Apply the hash.
        hashObj.setHash(hash);

        // Resolve the resource.
        kcCResource resource = GreatQuestUtils.findResourceByHash(parentFile, (GreatQuestInstance) gameObj.getGameInstance(), hash);
        if (resource != null) {
            if (!resourceClass.isInstance(resource))
                throw new ClassCastException("Resolved hash " + hashObj.getHashNumberAsString() + " to a " + Utils.getSimpleName(resource) + " named '" + resource.getName() + "', but a " + resourceClass.getName() + " was expected instead!");

            TResource castedResource = resourceClass.cast(resource);
            hashObj.setResource(castedResource, true);
            return true;
        } else {
            if (warnIfNotFound && hash != 0 && hash != -1)
                gameObj.getLogger().warning("Failed to resolve " + resourceClass.getSimpleName() + " by its " + Utils.getSimpleName(gameObj) + " hash: " + hashObj.getHashNumberAsString() + ".");
            return false;
        }
    }

    /**
     * Find a resource by its hash
     * @param parentFile the parent file. searched first
     * @param mainInstance the main game instance, all chunked files are searched if not found
     * @param resourceHash the resource hash to lookup
     * @return resourceOrNull
     * @param <TResult> the type of result to return
     */
    public static <TResult extends kcCResource> TResult findResourceByHash(GreatQuestChunkedFile parentFile, GreatQuestInstance mainInstance, int resourceHash) {
        TResult foundResult = parentFile != null ? parentFile.getResourceByHash(resourceHash) : null;
        if (foundResult != null)
            return foundResult;

        // Global search.
        for (GreatQuestArchiveFile file : mainInstance.getMainArchive().getFiles()) {
            if (!(file instanceof GreatQuestChunkedFile) || (parentFile == file))
                continue;

            GreatQuestChunkedFile chunkedFile = (GreatQuestChunkedFile) file;
            foundResult = chunkedFile.getResourceByHash(resourceHash);
            if (foundResult != null)
                return foundResult;
        }

        return null;
    }

    /**
     * Find a generic resource by its hash
     * @param parentFile the parent file. searched first
     * @param mainInstance the main game instance, all chunked files are searched if not found
     * @param resourceHash the resource hash to lookup
     * @param transformer the transformer to get the real resource from the generic one
     * @return genericResourceOrNull
     * @param <TResult> the type of result to return
     */
    public static <TResult> TResult findGenericResourceByHash(GreatQuestChunkedFile parentFile, GreatQuestInstance mainInstance, int resourceHash, Function<kcCResourceGeneric, TResult> transformer) {
        kcCResourceGeneric genericResult = parentFile != null ? parentFile.getResourceByHash(resourceHash) : null;
        if (genericResult != null) {
            TResult transformedResult = transformer.apply(genericResult);
            if (transformedResult != null)
                return transformedResult;
        }

        // Global search.
        for (GreatQuestArchiveFile file : mainInstance.getMainArchive().getFiles()) {
            if (!(file instanceof GreatQuestChunkedFile) || (parentFile == file))
                continue;

            GreatQuestChunkedFile chunkedFile = (GreatQuestChunkedFile) file;
            genericResult = chunkedFile.getResourceByHash(resourceHash);
            TResult transformedResult = genericResult != null ? transformer.apply(genericResult) : null;
            if (transformedResult != null)
                return transformedResult;
        }

        return null;
    }

    /**
     * Fill empty alpha pixels with visible alternating color pattern.
     * Used to identify textures which aren't loading (or aren't getting used) properly.
     * We need to find a better solution.
     * @param source the image to apply
     * @return newImage
     */
    public static BufferedImage fillEmptyAlpha(BufferedImage source) {
        if (source == null)
            return null;

        BufferedImage result = null;
        for (int y = 0; y < source.getHeight(); y++) {
            for (int x = 0; x < source.getWidth(); x++) {
                int argbColor = source.getRGB(x, y);
                int alpha = argbColor >>> 24;
                if (alpha != 0)
                    continue;

                // Create result.
                if (result == null)
                    result = ImageWorkHorse.copyImage(source);

                // Calculate color.
                int fixedColor;
                if (argbColor != 0) {
                    fixedColor = argbColor | 0xFF000000;
                } else if ((x + (y % 2)) % 2 > 0) {
                    fixedColor = 0xFF000000; // Black;
                } else {
                    fixedColor = 0xFFFF00FF; // Magenta
                }

                result.setRGB(x, y, fixedColor);
            }
        }

        return result != null ? result : source;

    }

    /**
     * Skip bytes, requiring the bytes skipped be 0 or the alternate value.
     * @param reader The reader to read padding from.
     * @param byteCount The number of bytes to skip.
     * @param alternateValue The alternative value besides 0x00 which is allowed.
     */
    public static void skipPaddingRequireEmptyOrByte(DataReader reader, int byteCount, byte alternateValue) {
        int index = reader.getIndex();
        if (byteCount == 0)
            return;

        if (byteCount < 0)
            throw new RuntimeException("Tried to skip " + byteCount + " bytes.");

        // Skip bytes.
        for (int i = 0; i < byteCount; i++) {
            byte nextByte = reader.readByte();
            if (nextByte != Constants.NULL_BYTE && nextByte != alternateValue)
                throw new RuntimeException("Reader wanted to skip " + byteCount + " bytes to reach " + Utils.toHexString(index + byteCount) + ", but got 0x" + Utils.toByteString(nextByte) + " at " + Utils.toHexString(index + i) + " when 0x" + Utils.toByteString(alternateValue) + " or 0x00 were expected.");
        }
    }

    /**
     * Adds a listener for a kcCResource which will apply a suffix to its name and use that new string for the hash.
     * @param resource the resource to apply the listener to
     * @param suffix the suffix to apply to the name
     */
    public static void applySelfNameSuffixAndToFutureNameChanges(kcCResource resource, String suffix) {
        if (resource == null)
            throw new NullPointerException("resource");
        if (suffix == null)
            throw new NullPointerException("suffix");

        if (resource.getSelfHash().getOriginalString() == null) {
            // Setup the name based on the suffix.
            resource.getSelfHash().setOriginalString(resource.getName() + suffix);
        } else if (!resource.getSelfHash().getOriginalString().endsWith(suffix)) {
            // Not sure what the original name is, but it doesn't end with our suffix, so we should not apply the suffix to future options.
            return;
        }

        // Listen for future names.
        resource.getNameProperty().addListener((property, oldName, newName) -> {
            if (resource.getHash() == -1)
                return; // Don't apply a new name if the hash is -1.

            if (newName == null)
                throw new NullPointerException("The " + Utils.getSimpleName(resource) + "/" + resource + " did not supply a name!");

            String newHashName = newName.endsWith(suffix) ? newName : newName + suffix;
            resource.getSelfHash().setHash(newHashName);
        });
    }
}