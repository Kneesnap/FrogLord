package net.highwayfrogs.editor.games.konami.greatquest;

import javafx.scene.Node;
import javafx.scene.transform.Rotate;
import javafx.scene.transform.Transform;
import lombok.SneakyThrows;
import net.highwayfrogs.editor.Constants;
import net.highwayfrogs.editor.file.config.Config;
import net.highwayfrogs.editor.file.vlo.ImageWorkHorse;
import net.highwayfrogs.editor.games.generic.data.IGameObject;
import net.highwayfrogs.editor.games.konami.greatquest.GreatQuestHash.kcHashedResource;
import net.highwayfrogs.editor.games.konami.greatquest.chunks.GreatQuestChunkedFile;
import net.highwayfrogs.editor.games.konami.greatquest.chunks.kcCResource;
import net.highwayfrogs.editor.games.konami.greatquest.entity.kcBaseDesc;
import net.highwayfrogs.editor.games.konami.greatquest.file.GreatQuestArchiveFile;
import net.highwayfrogs.editor.games.konami.greatquest.generic.kcCResourceGeneric;
import net.highwayfrogs.editor.utils.*;
import net.highwayfrogs.editor.utils.data.reader.DataReader;
import net.highwayfrogs.editor.utils.data.writer.DataWriter;
import net.highwayfrogs.editor.utils.objects.StringNode;

import java.awt.image.BufferedImage;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.util.*;
import java.util.function.Function;
import java.util.zip.Deflater;
import java.util.zip.Inflater;

/**
 * Contains static utilities for The Great Quest.
 * Created by Kneesnap on 8/17/2019.
 */
public class GreatQuestUtils {
    private static boolean loadedFileListConfiguration;
    private static final Map<Integer, String> FILENAMES_BY_HASH = new HashMap<>();
    private static final Map<Integer, List<String>> COLLIDING_FILE_PATHS = new HashMap<>();

    private static final List<String> ALL_HARDCODED_STRINGS_TO_HASH = new ArrayList<>();

    // This list was generated by finding all the hardcoded strings which get hashed in Frogger TGQ PAL PS2.
    // They have all been verified to hash with ignoreCase true.
    private static final List<String> GENERAL_HASHED_STRINGS = new ArrayList<>(Arrays.asList(
            "FrogInst001", "OctTreeSceneMgr", "DontPrepare", "NrmIdle01", "scriptdata",
            "C001FrogParams", "GooHitParticleParam", "frogoo2.img", "ParticleParam", "UdrWtrBubbleParticleParam",
            "bubble.img", "FireBallParticleParam", "spark.img", "SpeedStoneParticleParam", "GOOBER.VTX",
            "S_FIRE.VTX", "HitFlashParticleParam", "S_ICE.VTX", "HitFlashParticleParam", "SnowParticleParam",
            "S_WIND.VTX", "C001NrmReac01.bae", "C001NrmReac02.bae", "C001NrmReac03.bae", "HitPuff1ParticleParam",
            "HitFlyOutParticleParam", "C001FlyTrnsRun.bae", "C001NrmRun01.bae", "C001NrmWalk01.bae",
            "C001NrmWalk02.bae", "IceHitParticleParam", "FireBallParticleParam", "TorchParticleParam",
            "SavPointParticleParam", "SplashParticleParam", "SplashCParticleParam", "C001Shrink.bae",
            "FrogDieParticleParam", "FrogDieGParticleParam", "FrogDieLParticleParam", "FrogDieSParticleParam",
            "GemPickupParticleParam", "StonePickup01", "CoinSprkCParticleParam", "CoinSprkSParticleParam", "CoinSprkGParticleParam",
            "KeyPikupParticleParam", "UniqueItemParticleParam", "ModeAfterMovie", "MovieContinueGame",
            "FrogSpawnParticleParam", "CoinPickupParticleParam", "_kcEnvironment", "null"));

    // These are entities which are registered by the game itself, but are not registered to the static entity lookup map kcCEntity::mpInstanceMap.
    private static final List<String> UNMAPPED_SYSTEM_ENTITIES = Collections.singletonList(
            "ParticleMgr" // 0x2F5AFD67, kcCParticleMgr, Added by CGreatQuest::Init()
    );

    // These are entities which are possible to search by hash, because they are registered in kcCEntity::mpInstanceMap.
    private static final List<String> MAPPED_SYSTEM_ENTITIES = Arrays.asList(
            "ScriptCamera", // 0x725CE60F, kcCCameraPivot, Added by EvLevelBegin(), kcCCameraPivot::chDefaultHandle
            "FollowCamera", // 0x815DBBEB, kcCCameraFollow, Added by EvLevelBegin(), kcCCameraFollow::chDefaultHandle
            "WaypointMgr", // 0x69F9EA6C, kcCParticleMgr, Added by kcCGameSystem::Init()
            "kcGlobalDialog", // 0x72FA6003, kcCDialog, Added by EvLevelBegin()
            "CameraStack" // 0x2464F220, kcCCameraStack, Added by EvLevelBegin()
    );

    // These are all event names seen in PS2 PAL in RegisterEvents(), kcRegisterEvents(), InitMode(), modeMovieInit(), and InitMovie().
    // All usages of kcCEventMgr::Trigger(),  were checked to ensure none are missing too.
    private static final List<String> EVENT_NAMES = Arrays.asList(
            "LevelLoad", "LevelLoadComplete", "LevelBegin", "LevelCompleted", "LevelEnd", "LevelUnload", "LevelUnloadComplete", // InitMode(), RegisterEvents(), kcRegisterEvents()
            "PlayerAttack", "PlayerDamage", "PlayerDead", "BeginScreenFade", "EndScreenFade", // InitMode()
            "StartMovie", "CutMovie", "MovieCutFog", // InitMovie()
            "ModeAfterMovie", // modeMovieInit()
            "MovieContinueGame", // PlayMovieUpdate()
            "LockPlayerControl", "UnlockPlayerControl", "DialogBegin", "DialogAdvance", "DialogEnd", // kcRegisterEvents()
            "ShakeCameraRand", "TracePublicEvent", "EvStartDemoBGM", // kcRegisterEvents()
            "PlayMidMovie01", "PlayMidMovie02", "PlayMidMovie03", "PlayMidMovie04", "PlayMidMovie05", "PlayMidMovie06", // RegisterEvents()
            "PlayMidMovie07", "PlayMidMovie08", "PlayMidMovie09", "PlayMidMovie10"); // RegisterEvents()

    // In the same functions registering the events above, they can register what appear to be display names as "public event info", linked to the original via kcCEventMgr::AddPublicEventInfo().
    // Either this was something in their editor, or some old functionality, but I think this is unused?
    private static final List<String> EVENT_PUBLIC_INFO_NAMES = Arrays.asList(
            "Level Begin", // LevelBegin
            "Level End", // LevelEnd
            "Lock Player Controls", // LockPlayerControl
            "Unlock Player Controls", // UnlockPlayerControl
            "Shake Camera (random)", // ShakeCameraRand
            "StartDemoBGM", // EvStartDemoBGM
            "End Screen Fade (Fade to clear)", // EndScreenFade
            "Begin Screen Fade (Fade to black)", // BeginScreenFade
            "Level Complete (this ends the level)", // LevelCompleted
            "Play Dragon Fire Movie", // PlayMidMovie01
            "Play Dragon Smoke Movie", // PlayMidMovie09
            "Play Witch Movie", // PlayMidMovie02
            "Play Ckicken Emerge Movie", // PlayMidMovie03
            "Play Battle Movie", // PlayMidMovie05
            "Play General Entering Movie", // PlayMidMovie10
            "Play Crusher Enlarge Movie"); // PlayMidMovie06

    // These are the class names seen in PS2 PAL.
    private static final List<String> CLASS_NAMES = Arrays.asList(
            "CSkyDome", // CSkyDome::__ct(), 0x45CF29BB
            "HoneyPot", // CHoneyPot::__ct(), 0xE982E68A (Yes, this is missing the 'C' at the start)
            "kcCCameraPivot", // kcCCameraPivot::__ct(), 0x2CB3B5FF
            "kcCParticleMgr", // kcCParticleMgr::__ct(), 0x278F7D67
            "kcBaseClass", // 0x65357B17
            "kcCEntityMsgStore", // kcCEntity::MessagingInit(), 0xF03D0707
            "kcGenericString", // kcCreateStringResource(), 0x691277A3
            "CStats", "CInventory", "CCharacter", "CPropList", "kcCSensor", "CWaterMgr", "kcCAnimCtlBase",
            "kcCCameraStack", "kcCDialog", "kcCConsoleMain", "kcCParser", "kcCEnvironment", "kcCWaypointMgr",
            "kcCSceneMgr", "kcCAlarmMgr", "kcCEventMgr", "kcCResourceMgr", "kcCGameSystem", "kcCProxy", "kcCActor",
            "kcCHealth", "kcCEntity", "kcCTriMesh", "kcCEntity3D", "kcCResourceNamedHash", "kcCResourceActionSequence",
            "kcCAlarm", "CCoin", "CGem", "CMagicGem", "CHealthBug", "CItem", "CUniqueItem",
            "CCharacter", "CObjKey", "CObjMap", "CHoneyPot", "CMagicStone", "CProp",
            "CUniqueItem", "kcCProxyCapsule", "kcCCameraPid", "kcCCamera3P", "kcCGamePad", "WaypointMgr",
            "kcGlobalDialog", "kcCLight", "kcCAnimSet", "kcCModel", "kcCMsgPool", "kcCProcMgr", "kcCSkeleton",
            "kcCProxyTriMesh", "kcCAnimCtl", "kcCCameraBase", "kcCCameraFree", "kcCCameraPid", "kcCActorBase",
            "kcCCameraFollow", "kcCWaypoint", "kcCEmitter", "kcCParticleEmitter",
            "kcCScriptMgr" // This is also the name of the script manager entity, I think.
    );

    private static void loadFileList() {
        if (loadedFileListConfiguration)
            return;

        loadedFileListConfiguration = true;

        Config config = new Config(GreatQuestGameType.INSTANCE.getEmbeddedResourceStream("file-list.cfg"));
        for (Config fileListCfg : config.getOrderedChildren()) {
            for (String filePath : fileListCfg.getText()) {
                if (filePath.equalsIgnoreCase("UNKNOWN") || filePath.trim().isEmpty())
                    continue;

                int hash = hashFilePath(filePath);

                // Test if this file path matches an existing collision.
                List<String> collidingPaths = COLLIDING_FILE_PATHS.get(hash);
                if (collidingPaths != null) {
                    boolean pathAlreadySeen = false;
                    for (int i = 0; i < collidingPaths.size() && !pathAlreadySeen; i++)
                        if (collidingPaths.get(i).equalsIgnoreCase(filePath))
                            pathAlreadySeen = true;

                    // Found a new instance of the path, skip...!
                    if (!pathAlreadySeen)
                        collidingPaths.add(filePath);

                    continue;
                }

                String oldPath = FILENAMES_BY_HASH.putIfAbsent(hash, filePath);
                if (oldPath != null && !oldPath.equalsIgnoreCase(filePath)) {
                    // A collision has been found.
                    collidingPaths = new ArrayList<>();
                    collidingPaths.add(oldPath);
                    collidingPaths.add(filePath);
                    COLLIDING_FILE_PATHS.put(hash, collidingPaths);
                    if (!FILENAMES_BY_HASH.remove(hash, oldPath))
                        throw new RuntimeException("Failed to remove colliding hash from file name list.");
                }
            }
        }
    }

    /**
     * Apply default name hashes to a name hash map.
     * @param nameMap The map to update.
     */
    public static void addDefaultHashesToMap(Map<Integer, String> nameMap) {
        for (String str : ALL_HARDCODED_STRINGS_TO_HASH)
            nameMap.putIfAbsent(hash(str), str);

        for (kcClassID classID : kcClassID.values())
            if (classID.getName() != null && classID.getName().length() > 0)
                nameMap.putIfAbsent(hash(classID.getName()), classID.getName());
    }

    /**
     * Adds hardcoded file paths by their hashes to the map provided.
     * @param nameMap The map to update.
     */
    public static void addHardcodedFileNameHashesToMap(Map<Integer, String> nameMap) {
        loadFileList();
        nameMap.putAll(FILENAMES_BY_HASH);
    }

    /**
     * Compress data with zlib compression.
     * @param data The data to compress.
     * @return compressedData
     */
    @SneakyThrows
    public static byte[] zlibCompress(byte[] data) {
        Deflater deflater = new Deflater();
        deflater.setInput(data);
        ByteArrayOutputStream outputStream = new ByteArrayOutputStream(data.length);
        deflater.finish();
        byte[] buffer = new byte[1024];
        while (!deflater.finished()) {
            int count = deflater.deflate(buffer); // returns the generated code... index
            outputStream.write(buffer, 0, count);
        }
        outputStream.close();
        deflater.end();
        return outputStream.toByteArray();
    }

    /**
     * Decompress zlib data.
     * @param data The zlib data to decompress.
     * @return decompressedData
     */
    @SneakyThrows
    public static byte[] zlibDecompress(byte[] data, int resultSize) {
        byte[] result = new byte[resultSize];
        Inflater inflater = new Inflater();
        inflater.setInput(data);
        inflater.inflate(result);
        inflater.end();
        return result;
    }

    public static final String[] GAME_PATH_INDEX_PATTERNS = {"\\Game", "\\game", "\\GAME"};
    private static final String[] LEVEL_PATH_INDEX_PATTERNS = {"\\Level", "\\level", "\\LEVEL"};

    /**
     * Creates a file ID from a file path.
     * Example File Path: \\Netapp1\PD\Frogger1\PC\KatWorking\GameSource\Level01RollingRapids\Props\WalTreGL\WALTREGL.VTX
     * Example File ID: S01sPWalTreGL\WALTREGLX
     * The real game does not have any kind of error checking on file paths, for instance reading parts of the name which are not part of the string.
     * We may want to implement exceptions for this at a later date, even though the original game does not.
     * It also could stand to use some cleanup, but I want to keep this functionally identical for now.
     * Notes: The PC version is different from the PS2 version. This function was reversed from PS2, and modified for PC.
     * @param filePath The path to generate a file ID from.
     * @return fileId
     */
    public static String getFileIdFromPath(String filePath) { // Reversed from the 'Hash' function, in the global namespace. (To make it distinct from the other hash method)
        int gameIndex = indexOfMultiple(filePath, GAME_PATH_INDEX_PATTERNS);

        if (gameIndex != -1) { // If it was found.
            StringBuilder fileId = new StringBuilder();
            String cutPath = filePath.substring(gameIndex + 6); // Cut out \\game and everything before it.
            fileId.append(filePath.charAt(gameIndex + 5));
            int levelIndex = indexOfMultiple(cutPath, LEVEL_PATH_INDEX_PATTERNS);

            if (levelIndex != -1) {
                fileId.append(cutPath.charAt(levelIndex + 6));
                fileId.append(cutPath.charAt(levelIndex + 7));

                String cutSepString = cutPath.substring(levelIndex + 8);
                int sepIndex = cutSepString.indexOf('\\');
                if (sepIndex != -1) {
                    fileId.append(cutPath.charAt(levelIndex + 7 + sepIndex)); // Yes, this can result in getting data that is not in cutSepString, which is why it's getting it from cutPath.
                    fileId.append(cutSepString.charAt(sepIndex + 1));

                    String remaining = cutSepString.substring(sepIndex + 2);
                    int nextDirIndex = remaining.indexOf('\\');
                    if (nextDirIndex != -1) {
                        String fileName = remaining.substring(nextDirIndex + 1);
                        int extensionIndex = fileName.indexOf('.');
                        if (extensionIndex != -1) {
                            fileId.append(fileName, 0, extensionIndex);
                            fileId.append(fileName, fileName.length() - 1, fileName.length());
                            return fileId.toString();
                        }
                        return fileId.append(fileName).toString();
                    }
                    return fileId.append(remaining).toString();
                }
                return fileId.append(cutSepString).toString();
            }
            return fileId.append(cutPath).toString();
        } else {
            return filePath;
        }
    }

    /**
     * Calculates the checksum / hash of a string.
     * @param str The hash to use.
     * @return hash
     */
    public static int hash(String str) {
        return hash(str, true);
    }

    /**
     * Calculates the checksum / hash of a file path after it has been abbreviated.
     * @param filePath The file path to abbreviate and hash..
     * @return hash
     */
    public static int hashFilePath(String filePath) {
        return hash(getFileIdFromPath(filePath), true);
    }

    /**
     * Calculates the checksum / hash of a string.
     * This value is directly what is used in the Table of contents chunk.
     * @param str        The hash to use.
     * @param ignoreCase Whether case should be considered when hashing. There is no known situation where this should be false..
     * @return hash
     */
    public static int hash(String str, boolean ignoreCase) { // Reverse engineered the "Hash" function, in the kcHash (Hash table) namespace.
        if (str == null || str.isEmpty())
            return 0;

        int hash = str.length();
        for (int i = 0; i < str.length(); i++) {
            char tempChar = str.charAt(i);
            if (ignoreCase && (tempChar >= 'A') && (tempChar <= 'Z')) // If the letter is upper-case.
                tempChar = Character.toLowerCase(tempChar);

            hash = ((hash << 4) | ((hash >> 28) & 0x0F)) ^ (int) tempChar; // I'm pretty sure it's closer to the >>> behavior, but this works properly right now.
        }

        return hash;
    }

    /**
     * Undo a suffix from the hash.
     * If you have two or more hashes with a shared prefix, and know the suffix of each of the hashes that will make them match.
     * This hash is supposed to represent the hash of the original string, if it had been hashed with the suffix chopped off.
     * However, due to the length of the string being included in the hash, up to two bytes of the hash will not be the expected value.
     * If these bytes were together XOR'd with the full string length, then XOR'd by the chopped string length, that would correct this hash to become the hash of the chopped string.
     * For example reverseHash(DDFCEF0E, 'spike01g') -> 9B018C7E, where the real hash for 'S16nPTnlFence\' is 83018C7E. (9B vs 83).
     * When there are multiple hashes (multiple strings), it is possible to use this to our advantage, since it tells us which byte is modulo 8 of the real string length. (The byte which differs between two hashes of different length strings must be the one which has the length data, and we can calculate modulo 8 of the real string length from that.)
     * So in theory with multiple strings, it should be possible to calculate the full length of each string by looping through each string length with the correct modulo, then calculating the length of each provided string based on the calculated prefix length and the provided suffix length, then using XOR to tell which lengths cause a match between both hashes.
     * Whew that's kinda long-winded and not super clear, but I'm not sure if we'll ever need that functionality.
     *
     * Example:
     * File 1065 in PS2 PAL (\GameSource\Level01RollingRapids\Props\TunlGate\doorhndl copy.img) and File 1066 (\GameSource\Level01RollingRapids\Props\TunlGate\logend copy.img)
     * These files gave me a very hard time, because I saw there was already a folder called "TunlGate". Multiple 3D models use images that look like this, so I was confident that the file names "doorhndl.img" and "logend.img" were correct.
     * All of my effort went into trying to crack the folder name. "TunlGateOld", "TunlGateCopy", "TunlGate Copy", etc.
     * It wasn't until I tried reverse hashing to obtain the common prefix did it become clear that either there was no common prefix (highly unlikely given the sorted nature of the file list), or that I had given the wrong suffixes (file names).
     * From there I was able to instead focus on the file names, and easily found the " copy" was the part I had been missing.
     *
     * @param suffix The suffix known to be used at the end of the original string.
     * @param ignoreCase Whether case should be considered when hashing. There is no known situation where this should be false.
     * @return reversedHash
     */
    public static int reverseHash(int hash, String suffix, boolean ignoreCase) { // Reverse engineered the "Hash" function, in the kcHash (Hash table) namespace.
        if (suffix == null || suffix.isEmpty())
            return hash;

        for (int i = suffix.length() - 1; i >= 0; i--) {
            char tempChar = suffix.charAt(i);
            if (ignoreCase && (tempChar >= 'A') && (tempChar <= 'Z')) // If the letter is upper-case.
                tempChar = Character.toLowerCase(tempChar);

            hash ^= tempChar;
            hash = (hash >>> 4) | (hash << 28);
        }

        return hash;
    }

    /**
     * Find the index a string is found at, doing a case-insensitive search.
     * @param input    The string to search.
     * @param patterns The strings to find.
     * @return indexOfString
     */
    public static int indexOfMultiple(String input, String... patterns) {
        if (input == null || patterns == null || patterns.length == 0)
            return -1;

        for (int i = 0; i < patterns.length; i++) {
            int index = input.indexOf(patterns[i]);
            if (index != -1)
                return index;
        }

        return -1;
    }

    /**
     * Reads a boolean from the reader in the format Frogger TGQ stores them.
     * @param reader The reader to read from.
     * @return boolValue
     */
    public static boolean readTGQBoolean(DataReader reader) {
        int boolNumber = reader.readInt();
        if (boolNumber != 1 && boolNumber != 0)
            throw new RuntimeException("The int32 value was expected to be a boolean, but was actually " + boolNumber + ".");
        return boolNumber != 0;
    }

    /**
     * Reads a boolean from the reader in the format Frogger TGQ stores them.
     * @param reader The reader to read from.
     * @return boolValue
     */
    public static boolean readTGQByteBoolean(DataReader reader) {
        byte boolNumber = reader.readByte();
        if (boolNumber != 1 && boolNumber != 0)
            throw new RuntimeException("The byte value was expected to be a boolean, but was actually " + boolNumber + ".");
        return boolNumber != 0;
    }

    /**
     * Writes a boolean in the format Frogger TGQ stores them.
     * @param writer The writer to write to.
     * @param value  The boolean value to write.
     */
    public static void writeTGQBoolean(DataWriter writer, boolean value) {
        writer.writeInt(value ? 1 : 0);
    }

    /**
     * Writes a boolean in the format Frogger TGQ stores them.
     * @param writer The writer to write to.
     * @param value  The boolean value to write.
     */
    public static void writeTGQByteBoolean(DataWriter writer, boolean value) {
        writer.writeByte(value ? (byte) 1 : (byte) 0);
    }

    /**
     * Gets a Java file representing the file path to export an internal game system file to.
     * @param baseFolder The base folder to extract game files to.
     * @param file       The file to export.
     * @return exportFile
     */
    public static File getExportFile(File baseFolder, GreatQuestArchiveFile file) {
        File exportFolder;
        String fileName = null;
        if (file.hasFilePath()) {
            String tempPath = file.getFilePath();
            while (tempPath.startsWith("\\"))
                tempPath = tempPath.substring(1);

            int lastBackslash = tempPath.lastIndexOf('\\');
            if (lastBackslash != -1) {
                fileName = tempPath.substring(lastBackslash + 1);
                tempPath = tempPath.substring(0, lastBackslash);
            }

            exportFolder = new File(baseFolder, tempPath);
        } else {
            exportFolder = new File(new File(baseFolder, "Unidentified Files/"), file.getDefaultFolderName() + "/");
        }

        if (StringUtils.isNullOrEmpty(fileName))
            fileName = file.getExportName();

        FileUtils.makeDirectory(exportFolder);
        return new File(exportFolder, fileName);
    }

    /**
     * Resolves a resource hash to a particular asset.
     * @param resourceClass the desired resource class
     * @param resource the game object resolving the hash.
     * @param hashObj the hash object to save results within
     * @param hash the numerical hash to resolve.
     * @return if the resource was successfully resolved
     * @param <TResource> the type of resource to resolve
     */
    public static <TResource extends kcHashedResource> boolean resolveResourceHash(Class<TResource> resourceClass, kcCResource resource, GreatQuestHash<TResource> hashObj, int hash, boolean warnIfNotFound) {
        return resolveResourceHash(resourceClass, resource.getParentFile(), resource, hashObj, hash, warnIfNotFound);
    }

    /**
     * Resolves a resource hash to a particular asset.
     * @param resourceClass the desired resource class
     * @param gameObj the game object resolving the hash.
     * @param hashObj the hash object to save results within
     * @param hash the numerical hash to resolve.
     * @return if the resource was successfully resolved
     * @param <TResource> the type of resource to resolve
     */
    public static <TResource extends kcHashedResource> boolean resolveResourceHash(Class<TResource> resourceClass, kcBaseDesc gameObj, GreatQuestHash<TResource> hashObj, int hash, boolean warnIfNotFound) {
        return resolveResourceHash(resourceClass, gameObj.getParentFile(), gameObj, hashObj, hash, warnIfNotFound);
    }

    /**
     * Resolves a resource hash to a particular asset.
     * @param resourceClass the desired resource class
     * @param parentFile the file to find assets within
     * @param gameObj the game object resolving the hash.
     * @param hashObj the hash object to save results within
     * @param hash the numerical hash to resolve.
     * @param warnIfNotFound if true and the resource is not found, a warning will be written.
     * @return if the resource was successfully resolved
     * @param <TResource> the type of resource to resolve
     */
    public static <TResource extends kcHashedResource> boolean resolveResourceHash(Class<TResource> resourceClass, GreatQuestChunkedFile parentFile, IGameObject gameObj, GreatQuestHash<TResource> hashObj, int hash, boolean warnIfNotFound) {
        if (resourceClass == null)
            throw new NullPointerException("resourceClass");
        if (gameObj == null)
            throw new NullPointerException("gameObj");
        if (hashObj == null)
            throw new NullPointerException("hashObj");

        // Apply the hash.
        hashObj.setHash(hash);

        // Resolve the resource.
        kcCResource resource = GreatQuestUtils.findLevelResourceByHash(parentFile, hash);
        if (resource != null) {
            if (!resourceClass.isInstance(resource))
                throw new ClassCastException("Resolved hash " + hashObj.getHashNumberAsString() + " to a " + Utils.getSimpleName(resource) + " named '" + resource.getName() + "', but a " + resourceClass.getName() + " was expected instead!");

            TResource castedResource = resourceClass.cast(resource);
            hashObj.setResource(castedResource, true);
            return true;
        } else {
            if (warnIfNotFound && hash != 0 && hash != -1)
                gameObj.getLogger().warning("Failed to resolve " + resourceClass.getSimpleName() + " by its " + Utils.getSimpleName(gameObj) + " hash: " + hashObj.getHashNumberAsString() + ".");
            return false;
        }
    }

    /**
     * Find a resource by its hash
     * @param parentFile the parent file. searched first
     * @param mainInstance the main game instance, all chunked files are searched if not found
     * @param resourceHash the resource hash to lookup
     * @return resourceOrNull
     * @param <TResult> the type of result to return
     */
    public static <TResult extends kcCResource> TResult findResourceByHashGlobal(GreatQuestChunkedFile parentFile, GreatQuestInstance mainInstance, int resourceHash) {
        TResult foundResult = parentFile != null ? parentFile.getResourceByHash(resourceHash) : null;
        if (foundResult != null)
            return foundResult;

        // Global search.
        for (GreatQuestArchiveFile file : mainInstance.getMainArchive().getFiles()) {
            if (!(file instanceof GreatQuestChunkedFile) || (parentFile == file))
                continue;

            GreatQuestChunkedFile chunkedFile = (GreatQuestChunkedFile) file;
            foundResult = chunkedFile.getResourceByHash(resourceHash);
            if (foundResult != null)
                return foundResult;
        }

        return null;
    }

    /**
     * Find a resource available to the given level by the resource hash
     * @param parentFile the parent file, searched first. If not found, other chunked files loaded will be searched.
     * @param resourceHash the resource hash to lookup
     * @return resourceOrNull
     * @param <TResult> the type of result to return
     */
    public static <TResult extends kcCResource> TResult findLevelResourceByHash(GreatQuestChunkedFile parentFile, int resourceHash) {
        if (parentFile == null)
            throw new NullPointerException("parentFile");

        TResult foundResult = parentFile.getResourceByHash(resourceHash);
        if (foundResult != null)
            return foundResult;

        // Global search.
        GreatQuestInstance mainInstance = parentFile.getGameInstance();
        for (GreatQuestArchiveFile file : mainInstance.getMainArchive().getFiles()) {
            if (!(file instanceof GreatQuestChunkedFile) || (parentFile == file) || !"00.dat".equalsIgnoreCase(file.getFileName()))
                continue;

            GreatQuestChunkedFile chunkedFile = (GreatQuestChunkedFile) file;
            foundResult = chunkedFile.getResourceByHash(resourceHash);
            if (foundResult != null)
                return foundResult;
        }

        return null;
    }

    /**
     * Find a generic resource by its hash
     * @param parentFile the parent file. searched first
     * @param mainInstance the main game instance, all chunked files are searched if not found
     * @param resourceHash the resource hash to lookup
     * @param transformer the transformer to get the real resource from the generic one
     * @return genericResourceOrNull
     * @param <TResult> the type of result to return
     */
    public static <TResult> TResult findGenericResourceByHash(GreatQuestChunkedFile parentFile, GreatQuestInstance mainInstance, int resourceHash, Function<kcCResourceGeneric, TResult> transformer) {
        kcCResourceGeneric genericResult = parentFile != null ? parentFile.getResourceByHash(resourceHash) : null;
        if (genericResult != null) {
            TResult transformedResult = transformer.apply(genericResult);
            if (transformedResult != null)
                return transformedResult;
        }

        // Global search.
        for (GreatQuestArchiveFile file : mainInstance.getMainArchive().getFiles()) {
            if (!(file instanceof GreatQuestChunkedFile) || (parentFile == file))
                continue;

            GreatQuestChunkedFile chunkedFile = (GreatQuestChunkedFile) file;
            genericResult = chunkedFile.getResourceByHash(resourceHash);
            TResult transformedResult = genericResult != null ? transformer.apply(genericResult) : null;
            if (transformedResult != null)
                return transformedResult;
        }

        return null;
    }

    /**
     * Fill empty alpha pixels with visible alternating color pattern.
     * Used to identify textures which aren't loading (or aren't getting used) properly.
     * We need to find a better solution.
     * @param source the image to apply
     * @return newImage
     */
    public static BufferedImage fillEmptyAlpha(BufferedImage source) {
        if (source == null)
            return null;

        BufferedImage result = null;
        for (int y = 0; y < source.getHeight(); y++) {
            for (int x = 0; x < source.getWidth(); x++) {
                int argbColor = source.getRGB(x, y);
                int alpha = argbColor >>> 24;
                if (alpha != 0)
                    continue;

                // Create result.
                if (result == null)
                    result = ImageWorkHorse.copyImage(source);

                // Calculate color.
                int fixedColor;
                if (argbColor != 0) {
                    fixedColor = argbColor | 0xFF000000;
                } else if ((x + (y % 2)) % 2 > 0) {
                    fixedColor = 0xFF000000; // Black;
                } else {
                    fixedColor = 0xFFFF00FF; // Magenta
                }

                result.setRGB(x, y, fixedColor);
            }
        }

        return result != null ? result : source;

    }

    /**
     * Skip bytes, requiring the bytes skipped be 0 or the alternate value.
     * @param reader The reader to read padding from.
     * @param byteCount The number of bytes to skip.
     * @param alternateValue The alternative value besides 0x00 which is allowed.
     */
    public static void skipPaddingRequireEmptyOrByte(DataReader reader, int byteCount, byte alternateValue) {
        int index = reader.getIndex();
        if (byteCount == 0)
            return;

        if (byteCount < 0)
            throw new RuntimeException("Tried to skip " + byteCount + " bytes.");

        // Skip bytes.
        for (int i = 0; i < byteCount; i++) {
            byte nextByte = reader.readByte();
            if (nextByte != Constants.NULL_BYTE && nextByte != alternateValue)
                throw new RuntimeException("Reader wanted to skip " + byteCount + " bytes to reach " + NumberUtils.toHexString(index + byteCount) + ", but got 0x" + DataUtils.toByteString(nextByte) + " at " + NumberUtils.toHexString(index + i) + " when 0x" + DataUtils.toByteString(alternateValue) + " or 0x00 were expected.");
        }
    }

    /**
     * Adds a listener for a kcCResource which will apply a suffix to its name and use that new string for the hash.
     * @param resource the resource to apply the listener to
     * @param suffix the suffix to apply to the name
     */
    public static void applySelfNameSuffixAndToFutureNameChanges(kcCResource resource, String suffix) {
        if (resource == null)
            throw new NullPointerException("resource");
        if (suffix == null)
            throw new NullPointerException("suffix");

        if (resource.getSelfHash().getOriginalString() == null) {
            // Setup the name based on the suffix.
            resource.getSelfHash().setOriginalString(resource.getName() + suffix);
        } else if (!resource.getSelfHash().getOriginalString().endsWith(suffix)) {
            // Not sure what the original name is, but it doesn't end with our suffix, so we should not apply the suffix to future options.
            return;
        }

        // Listen for future names.
        resource.getNameProperty().addListener((property, oldName, newName) -> {
            if (resource.getHash() == -1)
                return; // Don't apply a new name if the hash is -1.

            if (newName == null)
                throw new NullPointerException("The " + Utils.getSimpleName(resource) + "/" + resource + " did not supply a name!");

            String newHashName = newName.endsWith(suffix) ? newName : newName + suffix;
            resource.getSelfHash().setHash(newHashName);
        });
    }

    /**
     * Set the rotation of an entity node in 3D space with the rotations applied the way rotations are applied to entities in Frogger: The Great Quest.
     * @param node node to update the rotation of
     * @param x x angle in radians
     * @param y y angle in radians
     * @param z z angle in radians
     * @param hasSkeleton true if there is a skeleton
     */
    public static void setEntityRotation(Node node, double x, double y, double z, boolean hasSkeleton) {
        Rotate xRotation = null;
        Rotate yRotation = null;
        Rotate zRotation = null;

        // How exactly we rotate the model may appear a little strange, but it is based on the behavior observed in the original game.
        // 1) There is a global rotation matrix, 'gChangeOfBasis', which is setup by kcCGameSystem::__ct to be a rotation on the X-axis by -PI / 2.
        // 2) Application:
        //  a) When evaluating skeleton bone transforms (kcCSkeleton::Execute), this gChangeOfBasis is the root matrix, meaning all bones are transformed by this (Thus rotated by PI / 2)
        //  b) kcCProxyTriMesh::BuildLcsToWcs will also do something.
        // So, when the entity has a skeleton, it will be rotated.
        Rotate skelRotation = null;

        for (Transform transform : node.getTransforms()) {
            if (!(transform instanceof Rotate))
                continue;

            Rotate rotate = (Rotate) transform;
            if (Rotate.X_AXIS.equals(rotate.getAxis())) {
                if (xRotation == null) {
                    xRotation = rotate;
                } else {
                    skelRotation = rotate;
                }
            } else if (Rotate.Y_AXIS.equals(rotate.getAxis())) {
                yRotation = rotate;
            } else if (Rotate.Z_AXIS.equals(rotate.getAxis())) {
                zRotation = rotate;
            }
        }

        // However, there's slightly more to it than the X rotation.
        // kcCEntity3D::BuildLcsToWcs() shows the rotation angles getting turned into matrices.
        // And, as such we must apply our rotations in the same order as the original code.
        // The original ordering was Y -> X -> Z, so that's how we'll do it.

        if (yRotation != null) {
            yRotation.setAngle(Math.toDegrees(y));
        } else {
            yRotation = new Rotate(Math.toDegrees(y), Rotate.Y_AXIS);
            node.getTransforms().add(yRotation);
        }

        if (xRotation != null) {
            xRotation.setAngle(Math.toDegrees(x));
        } else {
            xRotation = new Rotate(Math.toDegrees(x), Rotate.X_AXIS);
            node.getTransforms().add(xRotation);
        }

        if (zRotation != null) {
            zRotation.setAngle(Math.toDegrees(z));
        } else {
            zRotation = new Rotate(Math.toDegrees(z), Rotate.Z_AXIS);
            node.getTransforms().add(zRotation);
        }

        // The skeletal animation is last, so it doesn't break the Y or Z rotations.
        // See above for documentation on how this applied by the game.
        if (hasSkeleton) {
            if (skelRotation != null) {
                skelRotation.setAngle(Math.toDegrees(-Math.PI / 2));
            } else {
                skelRotation = new Rotate(Math.toDegrees(-Math.PI / 2), Rotate.X_AXIS);
                node.getTransforms().add(skelRotation);
            }
        } else if (skelRotation != null) {
            skelRotation.setAngle(0);
        }
    }

    /**
     * Gets the fileName from a full GreatQuest file path.
     * @param filePath the file path to get the file name from
     * @return fileName
     */
    public static String getFileNameFromPath(String filePath) {
        String fileName = filePath;

        int lastBackslashIndex = fileName.lastIndexOf('\\');
        if (lastBackslashIndex >= 0)
            fileName = fileName.substring(lastBackslashIndex + 1);

        int lastSlashIndex = fileName.lastIndexOf('/');
        if (lastSlashIndex >= 0)
            fileName = fileName.substring(lastSlashIndex + 1);

        return fileName;
    }

    /**
     * Interprets the given node as a hash
     * @param node the node to interpret
     * @param nullValue the value to return if a null or empty string is provided
     * @return hashValue
     */
    public static int getAsHash(StringNode node, int nullValue) {
        return node != null && node.getAsString() != null ? getAsHash(node.getAsString(), nullValue, null) : nullValue;
    }

    /**
     * Interprets the given node as a hash
     * @param node the node to interpret
     * @param nullValue the value to return if a null or empty string is provided
     * @return hashValue
     */
    public static int getAsHash(StringNode node, int nullValue, GreatQuestHash<?> hashObj) {
        String originalString;
        if (node != null && (originalString = node.getAsString()) != null) {
            return getAsHash(originalString, nullValue, hashObj);
        } else {
            if (hashObj != null)
                hashObj.setHash(nullValue);
            return nullValue;
        }
    }

    /**
     * Interprets the given string as a hash
     * @param input the string to interpret
     * @param nullValue the value to return if a null or empty string is provided
     * @param hashObj a hash object to apply the hash to. If null, it is ignored.
     * @return hashValue
     */
    public static int getAsHash(String input, int nullValue, GreatQuestHash<?> hashObj) {
        if (input == null || input.isEmpty()) {
            if (hashObj != null)
                hashObj.setHash(nullValue);
            return nullValue;
        } else if (NumberUtils.isHexInteger(input)) {
            int hash = NumberUtils.parseHexInteger(input);
            if (hashObj != null)
                hashObj.setHash(hash);
            return hash;
        } else {
            int hash = GreatQuestUtils.hash(input);
            if (hashObj != null)
                hashObj.setHash(hash, input, true);
            return hash;
        }
    }

    static {
        ALL_HARDCODED_STRINGS_TO_HASH.addAll(GENERAL_HASHED_STRINGS);
        ALL_HARDCODED_STRINGS_TO_HASH.addAll(UNMAPPED_SYSTEM_ENTITIES);
        ALL_HARDCODED_STRINGS_TO_HASH.addAll(MAPPED_SYSTEM_ENTITIES);
        ALL_HARDCODED_STRINGS_TO_HASH.addAll(EVENT_NAMES);
        ALL_HARDCODED_STRINGS_TO_HASH.addAll(EVENT_PUBLIC_INFO_NAMES);
        ALL_HARDCODED_STRINGS_TO_HASH.addAll(CLASS_NAMES);
    }
}