package net.highwayfrogs.editor.games.sony.oldfrogger.map.mesh;

import net.highwayfrogs.editor.file.standard.SVector;
import net.highwayfrogs.editor.file.vlo.GameImage;
import net.highwayfrogs.editor.games.sony.oldfrogger.map.OldFroggerMapFile;
import net.highwayfrogs.editor.games.sony.oldfrogger.map.packet.OldFroggerMapGridHeaderPacket.OldFroggerMapGrid;
import net.highwayfrogs.editor.games.sony.shared.shading.PSXShadeTextureDefinition;
import net.highwayfrogs.editor.gui.mesh.DynamicMeshAdapterNode;
import net.highwayfrogs.editor.gui.texture.ITextureSource;
import net.highwayfrogs.editor.gui.texture.Texture;
import net.highwayfrogs.editor.system.math.Vector2f;

/**
 * Represents a node in a map mesh for pre-recode frogger.
 * TODO: Vertices should be shared. UVs can probably be per-face.
 * Created by Kneesnap on 12/8/2023.
 */
public class OldFroggerMapMeshNode extends DynamicMeshAdapterNode<OldFroggerMapPolygon> {
    private final Vector2f tempVector = new Vector2f();

    public OldFroggerMapMeshNode(OldFroggerMapMesh mesh) {
        super(mesh);
    }

    @Override
    public OldFroggerMapMesh getMesh() {
        return (OldFroggerMapMesh) super.getMesh();
    }

    @Override
    protected void onAddedToMesh() {
        super.onAddedToMesh();

        for (OldFroggerMapGrid grid : getMap().getGridPacket().getGrids())
            for (OldFroggerMapPolygon polygon : grid.getPolygons())
                this.add(polygon);

        for (OldFroggerMapGrid grid : getMap().getGridPacket().getGrids())
            for (OldFroggerMapPolygon polygon : grid.getPolygons())
                this.setupFaces(polygon);
    }

    @Override
    protected void onRemovedFromMesh() {
        super.onRemovedFromMesh();
        // TODO: Let's automatically remove all data in the super method, just by having a method for it to get all of the entries.
    }

    @Override
    protected DynamicMeshTypedDataEntry writeValuesToArrayAndCreateEntry(OldFroggerMapPolygon data) {
        DynamicMeshTypedDataEntry entry = new DynamicMeshTypedDataEntry(getMesh(), data);

        // TODO: Vertices should be shared across all. (Debate different options ranging from putting all vertices in the first entry to making there always be one entry owned by the class, and not a specific node, to just having free-form management)
        for (int i = 0; i < data.getVertices().length; i++) {
            SVector vertexPos = getMap().getVertexPacket().getVertices().get(data.getVertices()[i]);
            entry.addVertexValue(vertexPos.getFloatX(), vertexPos.getFloatY(), vertexPos.getFloatZ());
        }

        ITextureSource textureSource = getMesh().getShadedTextureManager().getShadedTexture(data);
        Texture texture = getMesh().getTextureAtlas().getNullTextureFromSource(textureSource);

        // Use fallback texture if none found.
        if (texture == null)
            texture = getMesh().getTextureAtlas().getFallbackTexture();

        // Add texture UVs.
        entry.addTexCoordValue(getTextureCoordinate(data, textureSource, texture, 0, Vector2f.ZERO)); // uvTopLeft, 0F, 0F
        entry.addTexCoordValue(getTextureCoordinate(data, textureSource, texture, 1, Vector2f.UNIT_X)); // uvTopRight, 1F, 0F
        entry.addTexCoordValue(getTextureCoordinate(data, textureSource, texture, 2, Vector2f.UNIT_Y)); // uvBottomLeft, 0F, 1F
        entry.addTexCoordValue(getTextureCoordinate(data, textureSource, texture, 3, Vector2f.ONE)); // uvBottomRight, 1F, 1F

        return entry;
    }

    private Vector2f getTextureCoordinate(OldFroggerMapPolygon polygon, ITextureSource textureSource, Texture texture, int index, Vector2f fallback) {
        Vector2f localUv;
        if (polygon.getPolygonType().isTextured()) {
            localUv = polygon.getTextureUvs()[index].toVector(this.tempVector);
        } else {
            localUv = this.tempVector.setXY(fallback);
        }

        // Shaded untextured gouraud images generated by FrogLord include a small amount of padding.
        // This padding prevents bleeding colors from nearby textures.
        // Frogger does this normally for its textured polygons, but because untextured polygons don't have UVs,
        // it's our job to handle it here.
        if (textureSource instanceof PSXShadeTextureDefinition) {
            PSXShadeTextureDefinition shadeTexture = (PSXShadeTextureDefinition) textureSource;
            if (!shadeTexture.getPolygonType().isTextured()) {
                float minValue = (float) texture.getLeftPadding() / texture.getPaddedWidth();
                float maxValue = (float) (texture.getLeftPadding() + texture.getWidth()) / texture.getPaddedWidth();
                if (localUv.getX() == 0F)
                    localUv.setX(minValue);
                if (localUv.getX() == 1F)
                    localUv.setX(maxValue);
                if (localUv.getY() == 0F)
                    localUv.setY(minValue);
                if (localUv.getY() == 1F)
                    localUv.setY(maxValue);
            }
        }

        // Map textures seem to be flipped vertically,
        // and generated shaded textures are consistent with this behavior.
        if (textureSource instanceof PSXShadeTextureDefinition || textureSource instanceof GameImage)
            localUv.setY(1F - localUv.getY()); // UVs are flipped for generated shader textures too, in order to stay consistent.

        // Get the UVs local to the texture.
        return getMesh().getTextureAtlas().getUV(texture, localUv);
    }

    private void setupFaces(OldFroggerMapPolygon polygon) {
        DynamicMeshTypedDataEntry entry = getDataEntry(polygon);

        // Determine UV Indices.
        int uvIndex1 = entry.getTexCoordStartIndex();
        int uvIndex2 = entry.getTexCoordStartIndex() + 1;
        int uvIndex3 = entry.getTexCoordStartIndex() + 2;
        int uvIndex4 = entry.getTexCoordStartIndex() + 3;

        // Calculate vertices.
        int vtxIndex1 = entry.getVertexStartIndex();
        int vtxIndex2 = vtxIndex1 + 1;
        int vtxIndex3 = vtxIndex1 + 2;
        int vtxIndex4 = vtxIndex1 + 3;

        // JavaFX uses counter-clockwise winding order.
        entry.addFace(vtxIndex3, uvIndex3, vtxIndex2, uvIndex2, vtxIndex1, uvIndex1);
        entry.addFace(vtxIndex3, uvIndex3, vtxIndex4, uvIndex4, vtxIndex2, uvIndex2);
    }

    @Override
    public void updateVertex(DynamicMeshTypedDataEntry entry, int localVertexIndex) {
        OldFroggerMapPolygon vertex = entry.getDataSource();
        int vertexIndex = vertex.getVertices()[localVertexIndex];
        SVector vertexPos = getMap().getVertexPacket().getVertices().get(vertexIndex);
        entry.writeVertexXYZ(localVertexIndex, vertexPos.getFloatX(), vertexPos.getFloatY(), vertexPos.getFloatZ());
    }

    @Override
    public void updateTexCoord(DynamicMeshTypedDataEntry entry, int localTexCoordIndex) {
        OldFroggerMapPolygon vertex = entry.getDataSource();
        if (localTexCoordIndex == 0) {
            // TODO: FINISH
        } else if (localTexCoordIndex == 1) {
            // TODO: FINISH
        }
        // TODO: !
    }

    /**
     * Gets the map file which mesh data comes from.
     */
    public OldFroggerMapFile getMap() {
        return getMesh().getMap();
    }
}