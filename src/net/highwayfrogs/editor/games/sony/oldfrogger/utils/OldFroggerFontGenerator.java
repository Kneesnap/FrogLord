package net.highwayfrogs.editor.games.sony.oldfrogger.utils;

import net.highwayfrogs.editor.games.psx.math.vector.SVector;
import net.highwayfrogs.editor.games.sony.oldfrogger.OldFroggerGameInstance;
import net.highwayfrogs.editor.games.sony.shared.mof2.MRModel;
import net.highwayfrogs.editor.games.sony.shared.mof2.mesh.MRMofPart;
import net.highwayfrogs.editor.games.sony.shared.mof2.mesh.MRMofPolygon;
import net.highwayfrogs.editor.games.sony.shared.mof2.mesh.MRStaticMof;
import net.highwayfrogs.editor.games.sony.shared.mwd.WADFile;
import net.highwayfrogs.editor.games.sony.shared.mwd.WADFile.WADEntry;
import net.highwayfrogs.editor.utils.FileUtils;
import net.highwayfrogs.editor.utils.Utils;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * This is used to generate a python script which will create a font based on the 3D models seen in pre-recode Frogger.
 * FontForge documentation: <a href="https://fontforge.org/docs/tutorial/editexample.html"/>
 * Created by Kneesnap on 2/2/2026.
 */
public class OldFroggerFontGenerator {
    private static final String PYTHON_SCRIPT_BASE = "# This script is for FontForge, and is capable of generating a font from Frogger pre-recode's 3D letters.\n" +
            "# FontForge Tutorial: https://fontforge.org/docs/tutorial/editexample.html\n" +
            "# FontForge Documentation: https://fontforge.org/docs/scripting/python/fontforge.html\n" +
            "# This script was generated by FrogLord.\n" +
            "\"\"\"\n" + // This is a hack to get around the UI copy-paste size limit.
            "To run this script, open \"C:\\Program Files (x86)\\FontForgeBuilds\\fontforge-console.bat\"\n" +
            "Then, run \"ffpython <path to this file>\"\n" +
            "\"\"\"\n\n" +
            "import fontforge\n" +
            "#1) Create a new font\n" +
            "# Get active font: fontforge.activeFont() # fontforge.open(\"FroggerAuto.sfd\") # Open a font\n" +
            "font = fontforge.font() # Create a new font.\n" +
            "\n" +
            "#2) Apply a font name, copyright info, ascent/descent, and em size.\n" +
            "font.fullname = 'Frogger Main'\n" +
            "font.familyname = 'Frogger'\n" +
            "font.fontname = 'FroggerAuto'\n" +
            "font.comment = \"Generated automatically with FrogLord by Highway Frogs.\"\n" +
            "font.ascent = 800\n" +
            "font.descent = 200\n" +
            "font.em = 1000\n" +
            "\n" +
            "mult_x = font.em\n" +
            "mult_y = font.ascent\n" +
            "\n";

    /**
     * Saves a FontForge python script which will generate the Frogger font seen in 3D models in this game version.
     * @param instance the instance to save the script for
     */
    public static void saveFontForgePythonScript(OldFroggerGameInstance instance) {
        if (instance == null)
            throw new NullPointerException("instance");

        // Get the wad file containing the characters.
        WADFile wadFile = instance.getMainArchive().getFileByName("FRONT_0.WAD");
        if (wadFile == null)
            throw new IllegalArgumentException("The game did not contain the file 'FRONT_0.WAD'.");

        // Get a list of characters.
        List<MRModel> models = new ArrayList<>();
        for (WADEntry entry : wadFile.getFiles())
            if (entry.getFile() instanceof MRModel && FileUtils.stripExtension(entry.getDisplayName()).length() == 1)
                models.add((MRModel) entry.getFile());

        File outputFolder = instance.getMainGameFolder();
        String script = generateFontForgePythonScript(outputFolder, models);

        try {
            Files.write(new File(outputFolder, "font-forge-frogger-font-generator.py").toPath(), Arrays.asList(script.split("\n")));
            instance.getLogger().info("Wrote font generator script to the game instance folder.");
        } catch (IOException ex) {
            Utils.handleError(instance.getLogger(), ex, true, "Failed to save font generator script.");
        }
    }

    private static String generateFontForgePythonScript(File outputFolder, List<MRModel> models) {
        if (models == null || models.isEmpty())
            throw new NullPointerException("models");

        StringBuilder builder = new StringBuilder(PYTHON_SCRIPT_BASE);

        // Determine the minimum/maximum bounds of the font.
        short minX = Short.MAX_VALUE, minY = Short.MAX_VALUE;
        short maxX = Short.MIN_VALUE, maxY = Short.MIN_VALUE;
        for (MRModel model : models) {
            MRStaticMof staticMof = model.getStaticMof();
            if (staticMof == null)
                throw new IllegalArgumentException("Model '" + model.getFileDisplayName() + "' cannot be used because it is not a static model.");

            for (MRMofPart mofPart : staticMof.getParts()) {
                List<SVector> vertices = mofPart.getStaticPartcel().getVertices();
                for (SVector vertexPos : vertices) {
                    if (vertexPos.getX() < minX)
                        minX = vertexPos.getX();
                    if (vertexPos.getX() > maxX)
                        maxX = vertexPos.getX();
                    if (vertexPos.getZ() < minY)
                        minY = vertexPos.getZ();
                    if (vertexPos.getZ() > maxY)
                        maxY = vertexPos.getZ();
                }
            }
        }

        for (MRModel model : models) {
            String modelName = FileUtils.stripExtension(model.getFileDisplayName());
            if (modelName.length() > 1)
                throw new IllegalArgumentException("Model '" + model.getFileDisplayName() + "' is not valid for use in a font.");

            /*short minX = Short.MAX_VALUE, minY = Short.MAX_VALUE;
            short maxX = Short.MIN_VALUE, maxY = Short.MIN_VALUE;
            MRStaticMof staticMof = model.getStaticMof();
            if (staticMof == null)
                throw new IllegalArgumentException("Model '" + model.getFileDisplayName() + "' cannot be used because it is not a static model.");

            for (MRMofPart mofPart : staticMof.getParts()) {
                List<SVector> vertices = mofPart.getStaticPartcel().getVertices();
                for (SVector vertexPos : vertices) {
                    if (vertexPos.getX() < minX)
                        minX = vertexPos.getX();
                    if (vertexPos.getX() > maxX)
                        maxX = vertexPos.getX();
                    if (vertexPos.getZ() < minY)
                        minY = vertexPos.getZ();
                    if (vertexPos.getZ() > maxY)
                        maxY = vertexPos.getZ();
                }
            }*/

            char glyphName = modelName.charAt(0);
            generateFontGlyph(builder, model, glyphName, minX, minY, maxX, maxY);
            if (Character.isLetter(glyphName) && Character.toUpperCase(glyphName) != glyphName)
                generateFontGlyph(builder, model, Character.toUpperCase(glyphName), minX, minY, maxX, maxY);
            if (Character.isLetter(glyphName) && Character.toLowerCase(glyphName) != glyphName)
                generateFontGlyph(builder, model, Character.toLowerCase(glyphName), minX, minY, maxX, maxY);
        }

        builder.append("font.save(\"").append(new File(outputFolder, "FroggerAuto.sfd").toString().replace("\\", "\\\\")).append("\")\n");

        return builder.toString();
    }

    private static final int[] REGULAR_FACE = {0, 1, 2};
    private static final int[] QUAD_FACE_1 = {0, 1, 2};
    private static final int[] QUAD_FACE_2 = {1, 3, 2};

    private static void generateFontGlyph(StringBuilder builder, MRModel model, char glyphName, short minX, short minY, short maxX, short maxY) {
        builder.append("glyph = font.createChar(ord('").append(glyphName).append("'), \"").append(glyphName).append("\")\n");
        builder.append("pen = glyph.glyphPen()\n");

        MRStaticMof staticMof = model.getStaticMof();
        if (staticMof == null)
            throw new IllegalArgumentException("Model '" + model.getFileDisplayName() + "' cannot be used because it is not a static model.");

        List<MRMofPolygon> polygons = staticMof.getAllPolygons();
        for (int i = 0; i < polygons.size(); i++) {
            MRMofPolygon polygon = polygons.get(i);
            int vertexCount = polygon.getVertexCount();
            if (vertexCount == 4) {
                writeFace(builder, polygon, QUAD_FACE_1, minX, minY, maxX, maxY);
                writeFace(builder, polygon, QUAD_FACE_2, minX, minY, maxX, maxY);
            } else {
                writeFace(builder, polygon, REGULAR_FACE, minX, minY, maxX, maxY);
            }
        }

        builder.append("pen = None # Finalize the pen. This tells FontForge to do things like update the UI.\n\n");
    }

    private static void writeFace(StringBuilder builder, MRMofPolygon polygon, int[] localVertexIds, short minX, short minY, short maxX, short maxY) {
        for (int i = 0; i < localVertexIds.length; i++) {
            int localVtx = localVertexIds[i];
            SVector vertexPos = polygon.getMofPart().getStaticPartcel().getVertices().get(polygon.getVertices()[localVtx]);
            if (i == 0) {
                builder.append("pen.moveTo((");
            } else {
                builder.append("pen.lineTo((");
            }

            double x = (double) ((vertexPos.getX()) - minX) / (maxX - minX);
            double y = (double) ((vertexPos.getZ()) - minY) / (maxY - minY);
            builder.append("mult_x * ").append(x).append(", mult_y * ").append(y).append("))\n");
        }

        builder.append("pen.closePath()                       # end the contour\n");
    }
}
