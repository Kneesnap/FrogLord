package net.highwayfrogs.editor.games.sony.shared.vlo2.vram;

import lombok.Getter;
import lombok.NonNull;
import net.highwayfrogs.editor.games.sony.SCGameObject.SCSharedGameObject;
import net.highwayfrogs.editor.games.sony.shared.vlo2.VloImage;
import net.highwayfrogs.editor.utils.objects.IndexBitArray;

import java.util.ArrayList;
import java.util.List;

/**
 * The original games have a hardcoded array in a .c file generated by Vorg, representing all textures in the game.
 * Each texture is assigned a unique ID into this array, known as its texture ID.
 * This allows uniquely identifying textures in the original games, primarily so the source code can reference specific images by a name/macro.
 * Unfortunately, this means that in order to add new textures, we must fully recompile the game/expand the array to be larger.
 * At least that would be the case if we didn't have a workaround.
 * <p/>
 * Because not all VLO files are loaded simultaneously, it is possible to re-use texture IDs found in other VLO files, while those VLO files are not loaded.
 * The following system has been written to track which texture IDs are available for re-use in different VLO files.
 * <p/>
 * Each node tracks which texture IDs can be used.
 * A texture ID is considered "free" for a node if:
 *  - Neither the node nor its child nodes recursively have a VLO which uses the texture ID
 * <p/>
 * This puts significant upward pressure on the highest nodes of the tree. Eg: It is harder to find free texture IDs, the closer the node is to the root.
 * Because of this, when a free texture ID is procured, we will always prefer to return free texture IDs which are not free to a node's parent.
 * This will maximize the number of textures which can be added by FrogLord.
 * Created by Kneesnap on 1/19/2026.
 */
public class VloTextureIdTracker extends SCSharedGameObject {
    @Getter @NonNull private final VloTreeNode node;
    @Getter private final VloTextureIdTracker parentTracker;
    @Getter private final VloFileTreeData fileData;
    private final IndexBitArray freeTextureIds = new IndexBitArray();

    public VloTextureIdTracker(VloTreeNode node, VloTextureIdTracker parentTracker, VloFileTreeData fileData) {
        super(node.getInstance());
        this.node = node;
        this.parentTracker = parentTracker;
        this.fileData = fileData;
    }

    @Override
    public String toString() {
        // Get a list of all trackers.
        List<VloTextureIdTracker> trackers = new ArrayList<>();
        VloTextureIdTracker temp = this;
        while (temp != null) {
            trackers.add(temp);
            temp = temp.parentTracker;
        }

        StringBuilder builder = new StringBuilder(getClass().getSimpleName()).append("(");
        int startIndex = builder.length();
        for (int i = trackers.size() - 1; i >= 0; i--) {
            if (builder.length() > startIndex)
                builder.append(", ");

            VloTextureIdTracker tracker = trackers.get(i);
            builder.append(tracker.getName());
            builder.append(": ")
                    .append(tracker.freeTextureIds.getBitCount())
                    .append('/')
                    .append(getNumberOfFreeTextureIds(tracker));
        }

        return builder.append(")").toString();
    }

    /**
     * Resets the vlo texture ID tracker to the given size.
     * @param size the size to use
     */
    void reset(int size) {
        this.freeTextureIds.clear();
        this.freeTextureIds.setBits(0, size, true); // Mark all textures as free/available.
    }

    /**
     * Gets the name of this tracker.
     */
    public String getName() {
        return isVloTracker() ? this.fileData.getVloFileEntry().getDisplayName() : this.node.getName();
    }

    /**
     * Returns true if this tracker is specific to a VLO file, and not a node.
     * @return vloTracker
     */
    public boolean isVloTracker() {
        return this.fileData != null;
    }

    /**
     * Gets the number of free texture IDs usable by this tracker.
     * @param parentTracker if provided, and not this/null, it will return the number of textureIds which are
     * @return numberOfFreeTextureIds
     */
    public int getNumberOfFreeTextureIds(VloTextureIdTracker parentTracker) {
        if (parentTracker == null || parentTracker == this)
            return this.freeTextureIds.getBitCount();

        int tempIndex = -1;
        int freeTextureCount = 0;
        while ((tempIndex = this.freeTextureIds.getNextBitIndex(tempIndex)) >= 0)
            if (!parentTracker.freeTextureIds.getBit(tempIndex))
                freeTextureCount++; // Same behavior as useFreeTextureId()

        return freeTextureCount;
    }

    /**
     * Obtains a free texture ID usable by this tracker's VLO file, and marks it as restricted/non-free.
     * @return freeTextureId
     */
    public short useFreeTextureId() {
        if (!isVloTracker())
            throw new UnsupportedOperationException("Using a texture ID is only available to trackers belonging to a VloFile. (This one belongs to a VloTreeNode)");

        int tempIndex = -1;
        int textureId = -1;
        VloTextureIdTracker parentTracker = this;

        // While this.freeTextureIds.getFirstBitIndex() would be be both fast and valid to return, there's a downside.
        // Vlo files towards the top/root of the tree have the most amount of restricted textures.
        // So, if a parent node has the texture ID marked as free, it should be saved for use by the parent nodes, instead of used here.
        foundTextureId:
        while (parentTracker != null) {
            parentTracker = parentTracker.parentTracker;
            while ((tempIndex = this.freeTextureIds.getNextBitIndex(tempIndex)) >= 0) {
                textureId = tempIndex;
                if (parentTracker == null || !parentTracker.freeTextureIds.getBit(tempIndex))
                    break foundTextureId; // If the textureId isn't free in the parent, the texture ID will have no impact on other VLOs. (So we prefer to use this one first)
            }
        }

        // This should be very difficult to achieve in most game builds which will actually be modded.
        if (textureId < 0)
            throw new IllegalStateException("There are no more free texture IDs available to use here.");

        restrictTextureId((short) textureId); // Prevent the texture ID from being used somewhere else.
        return (short) textureId;
    }

    /**
     * Restricts a texture ID, so it will no longer be considered "free".
     * @param textureId the texture ID to restrict
     */
    public void restrictTextureId(short textureId) {
        if (!isVloTracker())
            throw new UnsupportedOperationException("Directly restricting a texture ID is only available to trackers belonging to a VloFile. (This one belongs to a VloTreeNode)");

        if (textureId < 0 || textureId > getGameInstance().getMaximumTextureId())
            throw new IllegalArgumentException("Invalid textureId: " + textureId);

        restrictTextureId(textureId, true, true, false);
    }

    // All VLOs in a node should recursively mark the parents as the texture as non-free.
    // But, all vlos sharing a node can use each other's textures.
    // All the node's child nodes should have it marked as restricted.
    // BUT, NONE of the node's child nodes should have it marked as restricted.
    private void restrictTextureId(short textureId, boolean restrictParent, boolean restrictChildren, boolean restrictVlos) {
        if (!this.freeTextureIds.setBit(textureId, false))
            return; // I am not sure if this is actually safe/valid to include, but I can't find any impact on the outcome if I include it.

        // Restrict parent tracker.
        if (restrictParent && this.parentTracker != null) // Skip setting Vlos of the parent for vlo trackers.
            this.parentTracker.restrictTextureId(textureId, true, false, !isVloTracker());

        // Restrict Vlo texture ID trackers.
        if (restrictVlos) {
            List<VloFileTreeData> dataEntries = this.node.getVloFileDataEntries();
            for (int i = 0; i < dataEntries.size(); i++)
                dataEntries.get(i).getTextureIdTracker().restrictTextureId(textureId, false, false, false);
        }

        // Restrict the texture ID from being used by any child nodes. (But the node's VLOs are not touched/are still able to use it)
        if (restrictChildren) {
            List<VloTreeNode> childNodes = this.node.getChildren();
            for (int i = 0; i < childNodes.size(); i++) {
                VloTreeNode childNode = childNodes.get(i);
                childNode.getTextureIdTracker().restrictTextureId(textureId, false, true, true);
            }
        }
    }

    /**
     * Frees the given texture ID for use in this tracker (and potentially others).
     * @param textureId the texture ID to free
     */
    public void freeTextureId(short textureId) {
        if (!isVloTracker())
            throw new UnsupportedOperationException("Directly freeing a texture ID is only available to trackers belonging to a VloFile. (This one belongs to a VloTreeNode)");
        if (textureId < 0 || textureId > getGameInstance().getMaximumTextureId())
            throw new IllegalArgumentException("Invalid textureId: " + textureId);

        // Mark the texture as free in the entire tree.
        List<VloTreeNode> queue = new ArrayList<>();
        queue.add(this.fileData.getNode().getTree()); // Start with the root node.
        while (queue.size() > 0) {
            VloTreeNode node = queue.remove(queue.size() - 1);

            // Set texture as free in trackers.
            List<VloFileTreeData> fileDataEntries = node.getVloFileDataEntries();
            node.getTextureIdTracker().freeTextureIds.setBit(textureId, true);
            for (int i = 0; i < fileDataEntries.size(); i++)
                fileDataEntries.get(i).getTextureIdTracker().freeTextureIds.setBit(textureId, true);

            // Queue child nodes.
            queue.addAll(node.getChildren());
        }

        // Restrict the texture ID for all remaining usages of this texture.
        List<VloImage> idUsages = getGameInstance().getMainArchive().getImagesByTextureId(textureId);
        for (int i = 0; i < idUsages.size(); i++) {
            VloImage image = idUsages.get(i);
            if (image.getParent().getIndexEntry() != this.fileData.getVloFileEntry()) // Skip the VLO which is tracked by this, as we've just been explicitly told to remove the texture ID for this VLO.
                restrictTextureId(textureId);
        }
    }
}