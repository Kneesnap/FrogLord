package net.highwayfrogs.editor.games.sony;

import lombok.NonNull;
import net.highwayfrogs.editor.Constants;
import net.highwayfrogs.editor.file.vlo.GameImage;
import net.highwayfrogs.editor.file.vlo.VLOArchive;
import net.highwayfrogs.editor.games.sony.SCGameConfig.SCImageList;
import net.highwayfrogs.editor.games.sony.shared.TextureRemapArray;
import net.highwayfrogs.editor.games.sony.shared.mwd.mwi.MWIResourceEntry;
import net.highwayfrogs.editor.utils.FileUtils;
import net.highwayfrogs.editor.utils.StringUtils;
import net.highwayfrogs.editor.utils.objects.IndexBitArray;

import java.io.File;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Comparator;
import java.util.List;
import java.util.Map.Entry;

/**
 * Contains static utilities for generating source files.
 * Created by Kneesnap on 9/17/2025.
 */
public class SCSourceFileGenerator {
    private static final DateFormat DATE_FORMAT = new SimpleDateFormat("EEEE, MMMM d yyyy 'at' kk:mm:ss");

    /**
     * Generates the .H file used in conjuntion with the .MWI/.MWD.
     * @param instance the instance to generate the header for
     * @param resourceDirectory the resource directory
     * @param file the file to save the mwd header as
     * @param fileTypePrefix the file type prefix
     * @param fileTypes the file types to define
     */
    public static void generateMwdCHeader(@NonNull SCGameInstance instance, @NonNull String resourceDirectory, @NonNull File file, @NonNull String fileTypePrefix, String... fileTypes) {
        String fileName = file.getName().toUpperCase();
        String ifdefName = "__" + fileName.replace('.', '_');

        StringBuilder builder = new StringBuilder();
        builder.append("//").append(Constants.NEWLINE)
                .append("//\t").append(fileName).append(Constants.NEWLINE)
                .append("//").append(Constants.NEWLINE)
                .append("//\t").append("Generated by FrogLord ").append(Constants.VERSION).append(" on ")
                .append(DATE_FORMAT.format(Calendar.getInstance().getTime())).append(Constants.NEWLINE)
                .append("//").append(Constants.NEWLINE)
                .append(Constants.NEWLINE)
                .append("#ifndef\t").append(ifdefName).append(Constants.NEWLINE)
                .append("#define\t").append(ifdefName).append(Constants.NEWLINE)
                .append(Constants.NEWLINE)
                .append("#define\tRES_").append(FileUtils.stripExtension(fileName)).append("_DIRECTORY\t\"")
                .append(resourceDirectory).append("\"").append(Constants.NEWLINE)
                .append(Constants.NEWLINE)
                .append(Constants.NEWLINE);

        // Determine longest file names.
        final String resourcePrefix = "RES_";
        int maxLength = "RES_NUMBER_OF_RESOURCES".length();
        for (MWIResourceEntry entry : instance.getArchiveIndex().getEntries()) {
            int testLength = resourcePrefix.length() + entry.getDisplayName().length();
            if (testLength > maxLength)
                maxLength = testLength;
        }

        // Write file types.
        for (int i = 0; i < fileTypes.length; i++) {
            String suffix = fileTypes[i];
            if (!StringUtils.isNullOrEmpty(suffix))
                writeDefineSymbol(builder, fileTypePrefix + "_FTYPE_" + suffix, maxLength, "(" + i + ")");
        }

        builder.append(Constants.NEWLINE)
                .append(Constants.NEWLINE);

        // Write file names.
        for (MWIResourceEntry entry : instance.getArchiveIndex().getEntries()) {
            String entryName = resourcePrefix + entry.getDisplayName().replace(".", "_");
            writeDefineSymbol(builder, entryName, maxLength, "(" + entry.getResourceId() + ")");
        }

        builder.append(Constants.NEWLINE);
        writeDefineSymbol(builder, "RES_NUMBER_OF_RESOURCES", maxLength, "(" + instance.getArchiveIndex().getEntries().size() + ")");
        builder.append(Constants.NEWLINE)
                .append(Constants.NEWLINE)
                .append("#endif\t//").append(ifdefName).append(Constants.NEWLINE);

        // Write to file.
        FileUtils.writeStringToFile(instance.getLogger(), file, builder.toString(), true);
    }

    private static void writeDefineSymbol(StringBuilder builder, String symbolName, int maxLength, String value) {
        builder.append("#define\t").append(symbolName);

        int paddedChars = maxLength - symbolName.length();
        for (int i = 0; i < paddedChars; i++)
            builder.append(' ');

        builder.append('\t').append(value).append(Constants.NEWLINE);
    }

    /**
     * Generates the source code file declaring images available for usage in an original source code repository.
     * @param instance the instance to generate the source file for
     * @param file the file to save the as
     * @param headerFileName the name of the header file
     */
    public static void generateVloResourceCFile(@NonNull SCGameInstance instance, @NonNull File file, String headerFileName) {
        String fileName = file.getName();
        if (StringUtils.isNullOrWhiteSpace(headerFileName))
            headerFileName = FileUtils.stripExtension(fileName) + (fileName.equals(fileName.toUpperCase()) ? ".H" : ".h");

        // Start building file.
        StringBuilder builder = new StringBuilder();
        builder.append("//").append(Constants.NEWLINE)
                .append("//\t").append(fileName).append(Constants.NEWLINE)
                .append("//").append(Constants.NEWLINE)
                .append("//\t").append("Generated by FrogLord ").append(Constants.VERSION).append(" on ")
                .append(DATE_FORMAT.format(Calendar.getInstance().getTime())).append(Constants.NEWLINE)
                .append("//").append(Constants.NEWLINE)
                .append(Constants.NEWLINE)
                .append("#include\t\"").append(headerFileName).append("\"").append(Constants.NEWLINE)
                .append(Constants.NEWLINE);

        // Get image mappings.
        List<GameImage> images = getStaticTextures(instance);
        List<GameImage> imagesById = new ArrayList<>();
        for (int i = 0; i < images.size(); i++) {
            GameImage image = images.get(i);

            while (image.getTextureId() >= imagesById.size())
                imagesById.add(null);

            imagesById.set(image.getTextureId(), image);
        }

        // Write bmp_pointers table.
        builder.append("MR_TEXTURE*\tbmp_pointers[] = {").append(Constants.NEWLINE).append('\t');
        int lastLineStart = builder.length();
        for (int i = 0; i < imagesById.size(); i++) {
            GameImage image = imagesById.get(i);

            int charCount = builder.length() - lastLineStart;
            if (charCount >= 120) {
                builder.append(Constants.NEWLINE).append("\t");
                lastLineStart = builder.length();
            } else if (i > 0) {
                builder.append(' ');
            }

            if (image != null) {
                builder.append('&')
                        .append(SCUtils.IMAGE_C_PREFIX)
                        .append(getImageName(image));
            } else {
                builder.append("NULL");
            }

            if (imagesById.size() > i + 1)
                builder.append(',');
        }
        builder.append(Constants.NEWLINE)
                .append("};")
                .append(Constants.NEWLINE)
                .append(Constants.NEWLINE);

        // Write texture remaps.
        for (int i = 0; i < instance.getTextureRemaps().size(); i++) {
            TextureRemapArray textureRemap = instance.getTextureRemaps().get(i);

            builder.append("MR_SHORT\t")
                    .append(textureRemap.getName())
                    .append("[] = {");

            int textureSlots = textureRemap.getTextureIdSlotsAvailable();
            for (int j = 0; j < textureSlots; j++) {
                if (j % 32 == 0) {
                    builder.append(Constants.NEWLINE).append("\t");
                } else {
                    builder.append(' ');
                }

                Short textureIdObj = textureRemap.getRemappedTextureId(j);
                int textureId = textureIdObj != null ? textureIdObj : 0;
                builder.append(textureId);

                if (textureSlots > j + 1)
                    builder.append(',');
            }

            builder.append(Constants.NEWLINE)
                    .append("};")
                    .append(Constants.NEWLINE)
                    .append(Constants.NEWLINE);
        }

        // Write image definitions.
        for (int i = 0; i < images.size(); i++) {
            GameImage image = images.get(i);
            builder.append("MR_TEXTURE\t")
                    .append(SCUtils.IMAGE_C_PREFIX)
                    .append(getImageName(image))
                    .append(";")
                    .append(Constants.NEWLINE);
        }

        // Write to file.
        FileUtils.writeStringToFile(instance.getLogger(), file, builder.toString(), true);
    }

    /**
     * Generates the header file used to declare the textures available in source code.
     * @param instance the instance to generate the header for
     * @param file the file to save the header as
     */
    public static void generateVloHeaderFile(@NonNull SCGameInstance instance, @NonNull File file, boolean writeFileNameMacros) {
        String fileName = file.getName().toUpperCase();
        String ifdefName = "__" + fileName.replace('.', '_');

        StringBuilder builder = new StringBuilder();
        builder.append("//").append(Constants.NEWLINE)
                .append("//\t").append(fileName).append(Constants.NEWLINE)
                .append("//").append(Constants.NEWLINE)
                .append("//\t").append("Generated by FrogLord ").append(Constants.VERSION).append(" on ")
                .append(DATE_FORMAT.format(Calendar.getInstance().getTime())).append(Constants.NEWLINE)
                .append("//").append(Constants.NEWLINE)
                .append(Constants.NEWLINE)
                .append("#ifndef\t").append(ifdefName).append(Constants.NEWLINE)
                .append("#define\t").append(ifdefName).append(Constants.NEWLINE)
                .append(Constants.NEWLINE);

        // Calculate and write the texture count.
        int textureCount = instance.getBmpTexturePointers().size();
        for (VLOArchive vloArchive : instance.getMainArchive().getAllFiles(VLOArchive.class))
            for (GameImage image : vloArchive.getImages())
                if (image.getTextureId() >= textureCount)
                    textureCount = image.getTextureId() + 1;

        String textureCountName = "NUM_TEXTURES";
        writeDefineSymbol(builder, textureCountName, textureCountName.length(), "(" + textureCount + ")");

        builder.append(Constants.NEWLINE).append(Constants.NEWLINE);

        // Write file name macros.
        SCImageList imageList = instance.getVersionConfig().getImageList();
        if (writeFileNameMacros && imageList != null) {
            List<Entry<Short, String>> sortedImageNames = new ArrayList<>(imageList.getImageNamesById().entrySet());
            sortedImageNames.sort(Comparator.comparingInt(entry -> (int) entry.getKey()));

            // Determine longest image names.
            final String resourcePrefix = "MRT_IM_";
            int maxLength = 0;
            for (int i = 0; i < sortedImageNames.size(); i++) {
                String suffix = sortedImageNames.get(i).getValue();
                int testLength = resourcePrefix.length() + suffix.length();
                if (testLength > maxLength)
                    maxLength = testLength;
            }

            // Write longest image names.
            for (int i = 0; i < sortedImageNames.size(); i++) {
                Entry<Short, String> entry = sortedImageNames.get(i);
                String suffix = entry.getValue();
                if (!StringUtils.isNullOrEmpty(suffix))
                    writeDefineSymbol(builder, resourcePrefix + suffix.toUpperCase(), maxLength, "(" + entry.getKey() + ")");
            }

            if (sortedImageNames.size() > 0) {
                builder.append(Constants.NEWLINE)
                        .append(Constants.NEWLINE);
            }
        }

        // Add bmp_pointers define.
        builder.append("extern\tMR_TEXTURE*\tbmp_pointers[];").append(Constants.NEWLINE)
                .append(Constants.NEWLINE);

        // Define each texture remap.
        List<TextureRemapArray> textureRemaps = instance.getTextureRemaps();
        for (int i = 0; i < textureRemaps.size(); i++) {
            TextureRemapArray textureRemap = textureRemaps.get(i);
            builder.append("extern\tMR_SHORT\t")
                    .append(textureRemap.getName())
                    .append("[];")
                    .append(Constants.NEWLINE);
        }

        if (textureRemaps.size() > 0)
            builder.append(Constants.NEWLINE);

        // Write texture definitions.
        List<GameImage> images = getStaticTextures(instance);

        for (int i = 0; i < images.size(); i++) {
            GameImage image = images.get(i);

            String imageName = getImageName(image);
            builder.append("extern\tMR_TEXTURE\t")
                    .append(SCUtils.IMAGE_C_PREFIX)
                    .append(imageName)
                    .append(";")
                    .append(Constants.NEWLINE);
        }

        // End
        builder.append(Constants.NEWLINE)
                .append("#endif\t//").append(ifdefName).append(Constants.NEWLINE);

        // Write to file.
        FileUtils.writeStringToFile(instance.getLogger(), file, builder.toString(), true);
    }

    private static List<GameImage> getStaticTextures(SCGameInstance instance) {
        IndexBitArray texturesSeen = new IndexBitArray();
        List<GameImage> images = new ArrayList<>();

        for (VLOArchive vloArchive : instance.getMainArchive().getAllFiles(VLOArchive.class)) {
            for (int i = 0; i < vloArchive.getImages().size(); i++) {
                GameImage image = vloArchive.getImages().get(i);
                if (image.testFlag(GameImage.FLAG_REFERENCED_BY_NAME) && !texturesSeen.getBit(image.getTextureId())) {
                    texturesSeen.setBit(image.getTextureId(), true);
                    images.add(image);
                }
            }
        }

        images.sort(Comparator.comparingInt(GameImage::getTextureId));

        return images;
    }

    private static String getImageName(GameImage image) {
        if (image == null)
            throw new NullPointerException("image");

        String imageName = image.getOriginalName();
        if (imageName != null)
            return imageName;

        return SCUtils.UNNAMED_IMAGE_PREFIX + image.getTextureId();
    }
}
